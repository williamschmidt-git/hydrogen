import path from 'path';
import fs from 'fs/promises';
import prettier from 'prettier';
import ts from 'typescript';
import glob from 'fast-glob';
import { outputDebug } from '@shopify/cli-kit/node/output';

const escapeNewLines = (code) => code.replace(/\n\n/g, "\n/* :newline: */");
const restoreNewLines = (code) => code.replace(/\/\* :newline: \*\//g, "\n");
const DEFAULT_TS_CONFIG = {
  lib: ["DOM", "DOM.Iterable", "ES2022"],
  isolatedModules: true,
  esModuleInterop: true,
  resolveJsonModule: true,
  target: "ES2022",
  strict: true,
  allowJs: true,
  forceConsistentCasingInFileNames: true,
  skipLibCheck: true
};
function transpileFile(code, config = DEFAULT_TS_CONFIG) {
  const withArtificialNewLines = escapeNewLines(code);
  const compiled = ts.transpileModule(withArtificialNewLines, {
    reportDiagnostics: false,
    compilerOptions: {
      ...config,
      jsx: 1,
      removeComments: false
    }
  });
  return restoreNewLines(compiled.outputText);
}
const DEFAULT_PRETTIER_CONFIG = {
  arrowParens: "always",
  singleQuote: true,
  bracketSpacing: false,
  trailingComma: "all"
};
async function resolveFormatConfig(filePath = process.cwd()) {
  try {
    return await prettier.resolveConfig(filePath) || DEFAULT_PRETTIER_CONFIG;
  } catch {
    return DEFAULT_PRETTIER_CONFIG;
  }
}
function format(content, config, filePath = "") {
  const ext = path.extname(filePath);
  const formattedContent = prettier.format(content, {
    parser: ext === ".tsx" || ext === ".ts" ? "typescript" : "babel",
    ...config
  });
  return formattedContent;
}
const DEFAULT_JS_CONFIG = {
  allowJs: true,
  forceConsistentCasingInFileNames: true,
  strict: true,
  lib: ["DOM", "DOM.Iterable", "ES2022"],
  esModuleInterop: true,
  isolatedModules: true,
  jsx: "react-jsx",
  noEmit: true,
  resolveJsonModule: true
};
const JS_CONFIG_KEYS = [
  "noLib",
  "target",
  "module",
  "moduleResolution",
  "checkJs",
  "experimentalDecorators",
  "allowSyntheticDefaultImports",
  "baseUrl",
  "paths",
  ...Object.keys(DEFAULT_JS_CONFIG)
];
function convertConfigToJS(tsConfig) {
  const jsConfig = {
    compilerOptions: { ...DEFAULT_JS_CONFIG }
  };
  if (tsConfig.include) {
    jsConfig.include = tsConfig.include.filter((s) => !s.endsWith(".d.ts")).map((s) => s.replace(/\.ts(x?)$/, ".js$1"));
  }
  if (tsConfig.compilerOptions) {
    for (const key of JS_CONFIG_KEYS) {
      if (tsConfig.compilerOptions[key] !== void 0) {
        jsConfig.compilerOptions[key] = tsConfig.compilerOptions[key];
      }
    }
  }
  return jsConfig;
}
async function transpileProject(projectDir) {
  const entries = await glob("**/*.+(ts|tsx)", {
    absolute: true,
    cwd: projectDir
  });
  const formatConfig = await resolveFormatConfig();
  for (const entry of entries) {
    if (entry.endsWith(".d.ts")) {
      await fs.rm(entry);
      continue;
    }
    const tsx = await fs.readFile(entry, "utf8");
    const mjs = format(transpileFile(tsx), formatConfig);
    await fs.rm(entry);
    await fs.writeFile(entry.replace(/\.ts(x?)$/, ".js$1"), mjs, "utf8");
  }
  try {
    const remixConfigPath = path.join(projectDir, "remix.config.js");
    let remixConfig = await fs.readFile(remixConfigPath, "utf8");
    remixConfig = remixConfig.replace(/\/server\.ts/gim, "/server.js");
    await fs.writeFile(remixConfigPath, remixConfig);
  } catch (error) {
    outputDebug(
      "Could not change TS extensions in remix.config.js:\n" + error.stack
    );
  }
  try {
    const tsConfigPath = path.join(projectDir, "tsconfig.json");
    const tsConfigWithComments = await fs.readFile(tsConfigPath, "utf8");
    const jsConfig = convertConfigToJS(
      JSON.parse(tsConfigWithComments.replace(/^\s*\/\/.*$/gm, ""))
    );
    await fs.rm(tsConfigPath);
    await fs.writeFile(
      path.join(projectDir, "jsconfig.json"),
      JSON.stringify(jsConfig, null, 2),
      "utf8"
    );
  } catch (error) {
    outputDebug(
      "Could not transpile tsconfig.json:\n" + error.stack
    );
  }
  try {
    const pkgJson = JSON.parse(
      await fs.readFile(path.join(projectDir, "package.json"), "utf8")
    );
    delete pkgJson.scripts["typecheck"];
    delete pkgJson.devDependencies["typescript"];
    delete pkgJson.devDependencies["@shopify/oxygen-workers-types"];
    for (const key of Object.keys(pkgJson.devDependencies)) {
      if (key.startsWith("@types/")) {
        delete pkgJson.devDependencies[key];
      }
    }
    await fs.writeFile(
      path.join(projectDir, "package.json"),
      JSON.stringify(pkgJson, null, 2)
    );
  } catch (error) {
    outputDebug(
      "Could not remove TS dependencies from package.json:\n" + error.stack
    );
  }
  try {
    const eslintrcPath = path.join(projectDir, ".eslintrc.js");
    let eslintrc = await fs.readFile(eslintrcPath, "utf8");
    eslintrc = eslintrc.replace(/\/\*\*[\s*]+@type.+\s+\*\/\s?/gim, "").replace(/\s*,?\s*['"`]plugin:hydrogen\/typescript['"`]/gim, "").replace(/\s+['"`]@typescript-eslint\/.+,/gim, "");
    await fs.writeFile(eslintrcPath, eslintrc);
  } catch (error) {
    outputDebug(
      "Could not remove TS rules from .eslintrc:\n" + error.stack
    );
  }
}

export { convertConfigToJS, format, resolveFormatConfig, transpileFile, transpileProject };
