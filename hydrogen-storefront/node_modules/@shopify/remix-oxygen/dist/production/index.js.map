{"version":3,"sources":["../../src/implementations.ts","../../src/crypto.ts","../../src/server.ts","../../src/index.ts"],"names":["createCookieFactory","createCookieSessionStorageFactory","createMemorySessionStorageFactory","createSessionStorageFactory","encoder","sign","value","secret","key","createKey","data","signature","hash","unsign","signed","index","byteStringToUint8Array","usages","byteString","array","i","createCookie","createCookieSessionStorage","createSessionStorage","createMemorySessionStorage","createRemixRequestHandler","createRequestHandler","build","mode","poweredByHeader","getLoadContext","handleRequest","request","response","getBuyerIp","getStorefrontHeaders","headers","createSession","defer","isCookie","isSession","json","MaxPartSizeExceededError","redirect","unstable_composeUploadHandlers","unstable_createMemoryUploadHandler","unstable_parseMultipartFormData"],"mappings":"AAAA,OACE,uBAAAA,EACA,qCAAAC,EACA,qCAAAC,EACA,+BAAAC,MACK,4BCHP,IAAMC,EAAU,IAAI,YAEPC,EAAqB,MAAOC,EAAOC,IAAW,CACzD,IAAMC,EAAM,MAAMC,EAAUF,EAAQ,CAAC,MAAM,CAAC,EACtCG,EAAON,EAAQ,OAAOE,CAAK,EAC3BK,EAAY,MAAM,OAAO,OAAO,KAAK,OAAQH,EAAKE,CAAI,EACtDE,EAAO,KAAK,OAAO,aAAa,GAAG,IAAI,WAAWD,CAAS,CAAC,CAAC,EAAE,QACnE,MACA,EACF,EAEA,OAAOL,EAAQ,IAAMM,CACvB,EAEaC,EAAyB,MAAOC,EAAQP,IAAW,CAC9D,IAAMQ,EAAQD,EAAO,YAAY,GAAG,EAC9BR,EAAQQ,EAAO,MAAM,EAAGC,CAAK,EAC7BH,EAAOE,EAAO,MAAMC,EAAQ,CAAC,EAE7BP,EAAM,MAAMC,EAAUF,EAAQ,CAAC,QAAQ,CAAC,EACxCG,EAAON,EAAQ,OAAOE,CAAK,EAC3BK,EAAYK,EAAuB,KAAKJ,CAAI,CAAC,EAGnD,OAFc,MAAM,OAAO,OAAO,OAAO,OAAQJ,EAAKG,EAAWD,CAAI,EAEtDJ,EAAQ,EACzB,EAEA,eAAeG,EACbF,EACAU,EACoB,CASpB,OARY,MAAM,OAAO,OAAO,UAC9B,MACAb,EAAQ,OAAOG,CAAM,EACrB,CAAC,KAAM,OAAQ,KAAM,SAAS,EAC9B,GACAU,CACF,CAGF,CAEA,SAASD,EAAuBE,EAAgC,CAC9D,IAAMC,EAAQ,IAAI,WAAWD,EAAW,MAAM,EAE9C,QAASE,EAAI,EAAGA,EAAIF,EAAW,OAAQE,IACrCD,EAAMC,GAAKF,EAAW,WAAWE,CAAC,EAGpC,OAAOD,CACT,CD3CO,IAAME,EAAerB,EAAoB,CAAC,KAAAK,EAAM,OAAAQ,CAAM,CAAC,EACjDS,EACXrB,EAAkCoB,CAAY,EACnCE,EAAuBpB,EAA4BkB,CAAY,EAC/DG,EACXtB,EAAkCqB,CAAoB,EEdxD,OACE,wBAAwBE,MAGnB,4BAEA,SAASC,EAAwC,CACtD,MAAAC,EACA,KAAAC,EACA,gBAAAC,EAAkB,GAClB,eAAAC,CACF,EAKG,CACD,IAAMC,EAAgBN,EAA0BE,EAAOC,CAAI,EAE3D,MAAO,OAAOI,GAAqB,CACjC,IAAMC,EAAW,MAAMF,EACrBC,EACC,MAAMF,IAAiBE,CAAO,CACjC,EAEA,OAAIH,GACFI,EAAS,QAAQ,OAAO,aAAc,UAAU,EAG3CA,CACT,CACF,CAEO,SAASC,EAAWF,EAAkB,CAC3C,OAAOA,EAAQ,QAAQ,IAAI,iBAAiB,GAAK,MACnD,CAQO,SAASG,EAAqBH,EAAqC,CACxE,IAAMI,EAAUJ,EAAQ,QACxB,MAAO,CACL,eAAgBI,EAAQ,IAAI,YAAY,EACxC,QAASA,EAAQ,IAAI,iBAAiB,EACtC,OAAQA,EAAQ,IAAI,QAAQ,CAC9B,CACF,CCzCA,OACE,iBAAAC,EACA,SAAAC,EACA,YAAAC,EACA,aAAAC,EACA,QAAAC,EACA,4BAAAC,EACA,YAAAC,EACA,kCAAAC,EACA,sCAAAC,EACA,mCAAAC,MACK","sourcesContent":["import {\n  createCookieFactory,\n  createCookieSessionStorageFactory,\n  createMemorySessionStorageFactory,\n  createSessionStorageFactory,\n} from '@remix-run/server-runtime';\n\nimport {sign, unsign} from './crypto';\n\nexport const createCookie = createCookieFactory({sign, unsign});\nexport const createCookieSessionStorage =\n  createCookieSessionStorageFactory(createCookie);\nexport const createSessionStorage = createSessionStorageFactory(createCookie);\nexport const createMemorySessionStorage =\n  createMemorySessionStorageFactory(createSessionStorage);\n","import type {SignFunction, UnsignFunction} from '@remix-run/server-runtime';\n\nconst encoder = new TextEncoder();\n\nexport const sign: SignFunction = async (value, secret) => {\n  const key = await createKey(secret, ['sign']);\n  const data = encoder.encode(value);\n  const signature = await crypto.subtle.sign('HMAC', key, data);\n  const hash = btoa(String.fromCharCode(...new Uint8Array(signature))).replace(\n    /=+$/,\n    '',\n  );\n\n  return value + '.' + hash;\n};\n\nexport const unsign: UnsignFunction = async (signed, secret) => {\n  const index = signed.lastIndexOf('.');\n  const value = signed.slice(0, index);\n  const hash = signed.slice(index + 1);\n\n  const key = await createKey(secret, ['verify']);\n  const data = encoder.encode(value);\n  const signature = byteStringToUint8Array(atob(hash));\n  const valid = await crypto.subtle.verify('HMAC', key, signature, data);\n\n  return valid ? value : false;\n};\n\nasync function createKey(\n  secret: string,\n  usages: CryptoKey['usages'],\n): Promise<CryptoKey> {\n  const key = await crypto.subtle.importKey(\n    'raw',\n    encoder.encode(secret),\n    {name: 'HMAC', hash: 'SHA-256'},\n    false,\n    usages,\n  );\n\n  return key;\n}\n\nfunction byteStringToUint8Array(byteString: string): Uint8Array {\n  const array = new Uint8Array(byteString.length);\n\n  for (let i = 0; i < byteString.length; i++) {\n    array[i] = byteString.charCodeAt(i);\n  }\n\n  return array;\n}\n","import {\n  createRequestHandler as createRemixRequestHandler,\n  type AppLoadContext,\n  type ServerBuild,\n} from '@remix-run/server-runtime';\n\nexport function createRequestHandler<Context = unknown>({\n  build,\n  mode,\n  poweredByHeader = true,\n  getLoadContext,\n}: {\n  build: ServerBuild;\n  mode?: string;\n  poweredByHeader?: boolean;\n  getLoadContext?: (request: Request) => Promise<Context> | Context;\n}) {\n  const handleRequest = createRemixRequestHandler(build, mode);\n\n  return async (request: Request) => {\n    const response = await handleRequest(\n      request,\n      (await getLoadContext?.(request)) as AppLoadContext,\n    );\n\n    if (poweredByHeader) {\n      response.headers.append('powered-by', 'Hydrogen');\n    }\n\n    return response;\n  };\n}\n\nexport function getBuyerIp(request: Request) {\n  return request.headers.get('oxygen-buyer-ip') ?? undefined;\n}\n\ntype StorefrontHeaders = {\n  requestGroupId: string | null;\n  buyerIp: string | null;\n  cookie: string | null;\n};\n\nexport function getStorefrontHeaders(request: Request): StorefrontHeaders {\n  const headers = request.headers;\n  return {\n    requestGroupId: headers.get('request-id'),\n    buyerIp: headers.get('oxygen-buyer-ip'),\n    cookie: headers.get('cookie'),\n  };\n}\n","export {\n  createCookie,\n  createCookieSessionStorage,\n  createMemorySessionStorage,\n  createSessionStorage,\n} from './implementations';\n\nexport {createRequestHandler, getBuyerIp, getStorefrontHeaders} from './server';\n\nexport {\n  createSession,\n  defer,\n  isCookie,\n  isSession,\n  json,\n  MaxPartSizeExceededError,\n  redirect,\n  unstable_composeUploadHandlers,\n  unstable_createMemoryUploadHandler,\n  unstable_parseMultipartFormData,\n} from '@remix-run/server-runtime';\n\nexport type {\n  ActionArgs,\n  ActionFunction,\n  AppData,\n  AppLoadContext,\n  Cookie,\n  CookieOptions,\n  CookieParseOptions,\n  CookieSerializeOptions,\n  CookieSignatureOptions,\n  DataFunctionArgs,\n  EntryContext,\n  ErrorBoundaryComponent,\n  HandleDataRequestFunction,\n  HandleDocumentRequestFunction,\n  HeadersFunction,\n  HtmlLinkDescriptor,\n  HtmlMetaDescriptor,\n  LinkDescriptor,\n  LinksFunction,\n  LoaderArgs,\n  LoaderFunction,\n  MemoryUploadHandlerFilterArgs,\n  MemoryUploadHandlerOptions,\n  MetaDescriptor,\n  MetaFunction,\n  PageLinkDescriptor,\n  RequestHandler,\n  RouteComponent,\n  RouteHandle,\n  SerializeFrom,\n  ServerBuild,\n  ServerEntryModule,\n  Session,\n  SessionData,\n  SessionIdStorageStrategy,\n  SessionStorage,\n  SignFunction,\n  TypedResponse,\n  UnsignFunction,\n  UploadHandler,\n  UploadHandlerPart,\n  V2_ServerRuntimeMetaArgs as V2_MetaArgs,\n  V2_ServerRuntimeMetaDescriptor as V2_MetaDescriptor,\n  // TODO: Remove in Remix v2\n  V2_ServerRuntimeMetaDescriptor as V2_HtmlMetaDescriptor,\n  V2_ServerRuntimeMetaFunction as V2_MetaFunction,\n} from '@remix-run/server-runtime';\n"]}