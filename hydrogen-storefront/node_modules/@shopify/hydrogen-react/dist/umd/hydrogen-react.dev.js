(function(global, factory) {
  typeof exports === "object" && typeof module !== "undefined" ? factory(exports, require("react")) : typeof define === "function" && define.amd ? define(["exports", "react"], factory) : (global = typeof globalThis !== "undefined" ? globalThis : global || self, factory(global.hydrogenreact = {}, global.React));
})(this, function(exports2, React) {
  "use strict";
  function _interopNamespaceDefault(e2) {
    const n2 = Object.create(null, { [Symbol.toStringTag]: { value: "Module" } });
    if (e2) {
      for (const k in e2) {
        if (k !== "default") {
          const d = Object.getOwnPropertyDescriptor(e2, k);
          Object.defineProperty(n2, k, d.get ? d : {
            enumerable: true,
            get: () => e2[k]
          });
        }
      }
    }
    n2.default = e2;
    return Object.freeze(n2);
  }
  const React__namespace = /* @__PURE__ */ _interopNamespaceDefault(React);
  /*! *****************************************************************************
    Copyright (c) Microsoft Corporation.
  
    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.
  
    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */
  function t(t2, n2) {
    var e2 = "function" == typeof Symbol && t2[Symbol.iterator];
    if (!e2)
      return t2;
    var r2, i2, o2 = e2.call(t2), a2 = [];
    try {
      for (; (void 0 === n2 || n2-- > 0) && !(r2 = o2.next()).done; )
        a2.push(r2.value);
    } catch (t3) {
      i2 = { error: t3 };
    } finally {
      try {
        r2 && !r2.done && (e2 = o2.return) && e2.call(o2);
      } finally {
        if (i2)
          throw i2.error;
      }
    }
    return a2;
  }
  var n;
  !function(t2) {
    t2[t2.NotStarted = 0] = "NotStarted", t2[t2.Running = 1] = "Running", t2[t2.Stopped = 2] = "Stopped";
  }(n || (n = {}));
  var e = { type: "xstate.init" };
  function r(t2) {
    return void 0 === t2 ? [] : [].concat(t2);
  }
  function i(t2) {
    return { type: "xstate.assign", assignment: t2 };
  }
  function o(t2, n2) {
    return "string" == typeof (t2 = "string" == typeof t2 && n2 && n2[t2] ? n2[t2] : t2) ? { type: t2 } : "function" == typeof t2 ? { type: t2.name, exec: t2 } : t2;
  }
  function a(t2) {
    return function(n2) {
      return t2 === n2;
    };
  }
  function u$1(t2) {
    return "string" == typeof t2 ? { type: t2 } : t2;
  }
  function c(t2, n2) {
    return { value: t2, context: n2, actions: [], changed: false, matches: a(t2) };
  }
  function f(t2, n2, e2) {
    var r2 = n2, i2 = false;
    return [t2.filter(function(t3) {
      if ("xstate.assign" === t3.type) {
        i2 = true;
        var n3 = Object.assign({}, r2);
        return "function" == typeof t3.assignment ? n3 = t3.assignment(r2, e2) : Object.keys(t3.assignment).forEach(function(i3) {
          n3[i3] = "function" == typeof t3.assignment[i3] ? t3.assignment[i3](r2, e2) : t3.assignment[i3];
        }), r2 = n3, false;
      }
      return true;
    }), r2, i2];
  }
  function s(n2, i2) {
    void 0 === i2 && (i2 = {});
    var s2 = t(f(r(n2.states[n2.initial].entry).map(function(t2) {
      return o(t2, i2.actions);
    }), n2.context, e), 2), l2 = s2[0], v2 = s2[1], y = { config: n2, _options: i2, initialState: { value: n2.initial, actions: l2, context: v2, matches: a(n2.initial) }, transition: function(e2, i3) {
      var s3, l3, v3 = "string" == typeof e2 ? { value: e2, context: n2.context } : e2, p = v3.value, g2 = v3.context, d = u$1(i3), x = n2.states[p];
      if (x.on) {
        var m = r(x.on[d.type]);
        try {
          for (var h = function(t2) {
            var n3 = "function" == typeof Symbol && Symbol.iterator, e3 = n3 && t2[n3], r2 = 0;
            if (e3)
              return e3.call(t2);
            if (t2 && "number" == typeof t2.length)
              return { next: function() {
                return t2 && r2 >= t2.length && (t2 = void 0), { value: t2 && t2[r2++], done: !t2 };
              } };
            throw new TypeError(n3 ? "Object is not iterable." : "Symbol.iterator is not defined.");
          }(m), b = h.next(); !b.done; b = h.next()) {
            var S = b.value;
            if (void 0 === S)
              return c(p, g2);
            var w = "string" == typeof S ? { target: S } : S, j = w.target, E = w.actions, R = void 0 === E ? [] : E, N = w.cond, O = void 0 === N ? function() {
              return true;
            } : N, _ = void 0 === j, k = null != j ? j : p, T = n2.states[k];
            if (O(g2, d)) {
              var q = t(f((_ ? r(R) : [].concat(x.exit, R, T.entry).filter(function(t2) {
                return t2;
              })).map(function(t2) {
                return o(t2, y._options.actions);
              }), g2, d), 3), z = q[0], A = q[1], B = q[2], C = null != j ? j : p;
              return { value: C, context: A, actions: z, changed: j !== p || z.length > 0 || B, matches: a(C) };
            }
          }
        } catch (t2) {
          s3 = { error: t2 };
        } finally {
          try {
            b && !b.done && (l3 = h.return) && l3.call(h);
          } finally {
            if (s3)
              throw s3.error;
          }
        }
      }
      return c(p, g2);
    } };
    return y;
  }
  var l$1 = function(t2, n2) {
    return t2.actions.forEach(function(e2) {
      var r2 = e2.exec;
      return r2 && r2(t2.context, n2);
    });
  };
  function v(t2) {
    var r2 = t2.initialState, i2 = n.NotStarted, o2 = /* @__PURE__ */ new Set(), c2 = { _machine: t2, send: function(e2) {
      i2 === n.Running && (r2 = t2.transition(r2, e2), l$1(r2, u$1(e2)), o2.forEach(function(t3) {
        return t3(r2);
      }));
    }, subscribe: function(t3) {
      return o2.add(t3), t3(r2), { unsubscribe: function() {
        return o2.delete(t3);
      } };
    }, start: function(o3) {
      if (o3) {
        var u2 = "object" == typeof o3 ? o3 : { context: t2.config.context, value: o3 };
        r2 = { value: u2.value, actions: [], context: u2.context, matches: a(u2.value) };
      } else
        r2 = t2.initialState;
      return i2 = n.Running, l$1(r2, e), c2;
    }, stop: function() {
      return i2 = n.Stopped, o2.clear(), c2;
    }, get state() {
      return r2;
    }, get status() {
      return i2;
    } };
    return c2;
  }
  var index = React.useLayoutEffect;
  var withSelectorExports = {};
  var withSelector = {
    get exports() {
      return withSelectorExports;
    },
    set exports(v2) {
      withSelectorExports = v2;
    }
  };
  var withSelector_development = {};
  var shimExports = {};
  var shim = {
    get exports() {
      return shimExports;
    },
    set exports(v2) {
      shimExports = v2;
    }
  };
  var useSyncExternalStoreShim_development = {};
  /**
   * @license React
   * use-sync-external-store-shim.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */
  {
    (function() {
      if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart === "function") {
        __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
      }
      var React$1 = React;
      var ReactSharedInternals = React$1.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
      function error(format) {
        {
          {
            for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
              args[_key2 - 1] = arguments[_key2];
            }
            printWarning("error", format, args);
          }
        }
      }
      function printWarning(level, format, args) {
        {
          var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
          var stack = ReactDebugCurrentFrame.getStackAddendum();
          if (stack !== "") {
            format += "%s";
            args = args.concat([stack]);
          }
          var argsWithFormat = args.map(function(item) {
            return String(item);
          });
          argsWithFormat.unshift("Warning: " + format);
          Function.prototype.apply.call(console[level], console, argsWithFormat);
        }
      }
      function is(x, y) {
        return x === y && (x !== 0 || 1 / x === 1 / y) || x !== x && y !== y;
      }
      var objectIs = typeof Object.is === "function" ? Object.is : is;
      var useState = React$1.useState, useEffect = React$1.useEffect, useLayoutEffect = React$1.useLayoutEffect, useDebugValue = React$1.useDebugValue;
      var didWarnOld18Alpha = false;
      var didWarnUncachedGetSnapshot = false;
      function useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {
        {
          if (!didWarnOld18Alpha) {
            if (React$1.startTransition !== void 0) {
              didWarnOld18Alpha = true;
              error("You are using an outdated, pre-release alpha of React 18 that does not support useSyncExternalStore. The use-sync-external-store shim will not work correctly. Upgrade to a newer pre-release.");
            }
          }
        }
        var value = getSnapshot();
        {
          if (!didWarnUncachedGetSnapshot) {
            var cachedValue = getSnapshot();
            if (!objectIs(value, cachedValue)) {
              error("The result of getSnapshot should be cached to avoid an infinite loop");
              didWarnUncachedGetSnapshot = true;
            }
          }
        }
        var _useState = useState({
          inst: {
            value,
            getSnapshot
          }
        }), inst = _useState[0].inst, forceUpdate = _useState[1];
        useLayoutEffect(function() {
          inst.value = value;
          inst.getSnapshot = getSnapshot;
          if (checkIfSnapshotChanged(inst)) {
            forceUpdate({
              inst
            });
          }
        }, [subscribe, value, getSnapshot]);
        useEffect(function() {
          if (checkIfSnapshotChanged(inst)) {
            forceUpdate({
              inst
            });
          }
          var handleStoreChange = function() {
            if (checkIfSnapshotChanged(inst)) {
              forceUpdate({
                inst
              });
            }
          };
          return subscribe(handleStoreChange);
        }, [subscribe]);
        useDebugValue(value);
        return value;
      }
      function checkIfSnapshotChanged(inst) {
        var latestGetSnapshot = inst.getSnapshot;
        var prevValue = inst.value;
        try {
          var nextValue = latestGetSnapshot();
          return !objectIs(prevValue, nextValue);
        } catch (error2) {
          return true;
        }
      }
      function useSyncExternalStore$1(subscribe, getSnapshot, getServerSnapshot) {
        return getSnapshot();
      }
      var canUseDOM = !!(typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined");
      var isServerEnvironment = !canUseDOM;
      var shim2 = isServerEnvironment ? useSyncExternalStore$1 : useSyncExternalStore;
      var useSyncExternalStore$2 = React$1.useSyncExternalStore !== void 0 ? React$1.useSyncExternalStore : shim2;
      useSyncExternalStoreShim_development.useSyncExternalStore = useSyncExternalStore$2;
      if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop === "function") {
        __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
      }
    })();
  }
  (function(module2) {
    {
      module2.exports = useSyncExternalStoreShim_development;
    }
  })(shim);
  /**
   * @license React
   * use-sync-external-store-shim/with-selector.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */
  {
    (function() {
      if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart === "function") {
        __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
      }
      var React$1 = React;
      var shim2 = shimExports;
      function is(x, y) {
        return x === y && (x !== 0 || 1 / x === 1 / y) || x !== x && y !== y;
      }
      var objectIs = typeof Object.is === "function" ? Object.is : is;
      var useSyncExternalStore = shim2.useSyncExternalStore;
      var useRef = React$1.useRef, useEffect = React$1.useEffect, useMemo = React$1.useMemo, useDebugValue = React$1.useDebugValue;
      function useSyncExternalStoreWithSelector(subscribe, getSnapshot, getServerSnapshot, selector, isEqual2) {
        var instRef = useRef(null);
        var inst;
        if (instRef.current === null) {
          inst = {
            hasValue: false,
            value: null
          };
          instRef.current = inst;
        } else {
          inst = instRef.current;
        }
        var _useMemo = useMemo(function() {
          var hasMemo = false;
          var memoizedSnapshot;
          var memoizedSelection;
          var memoizedSelector = function(nextSnapshot) {
            if (!hasMemo) {
              hasMemo = true;
              memoizedSnapshot = nextSnapshot;
              var _nextSelection = selector(nextSnapshot);
              if (isEqual2 !== void 0) {
                if (inst.hasValue) {
                  var currentSelection = inst.value;
                  if (isEqual2(currentSelection, _nextSelection)) {
                    memoizedSelection = currentSelection;
                    return currentSelection;
                  }
                }
              }
              memoizedSelection = _nextSelection;
              return _nextSelection;
            }
            var prevSnapshot = memoizedSnapshot;
            var prevSelection = memoizedSelection;
            if (objectIs(prevSnapshot, nextSnapshot)) {
              return prevSelection;
            }
            var nextSelection = selector(nextSnapshot);
            if (isEqual2 !== void 0 && isEqual2(prevSelection, nextSelection)) {
              return prevSelection;
            }
            memoizedSnapshot = nextSnapshot;
            memoizedSelection = nextSelection;
            return nextSelection;
          };
          var maybeGetServerSnapshot = getServerSnapshot === void 0 ? null : getServerSnapshot;
          var getSnapshotWithSelector = function() {
            return memoizedSelector(getSnapshot());
          };
          var getServerSnapshotWithSelector = maybeGetServerSnapshot === null ? void 0 : function() {
            return memoizedSelector(maybeGetServerSnapshot());
          };
          return [getSnapshotWithSelector, getServerSnapshotWithSelector];
        }, [getSnapshot, getServerSnapshot, selector, isEqual2]), getSelection = _useMemo[0], getServerSelection = _useMemo[1];
        var value = useSyncExternalStore(subscribe, getSelection, getServerSelection);
        useEffect(function() {
          inst.hasValue = true;
          inst.value = value;
        }, [value]);
        useDebugValue(value);
        return value;
      }
      withSelector_development.useSyncExternalStoreWithSelector = useSyncExternalStoreWithSelector;
      if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop === "function") {
        __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
      }
    })();
  }
  (function(module2) {
    {
      module2.exports = withSelector_development;
    }
  })(withSelector);
  function useConstant(fn) {
    var ref = React__namespace.useRef();
    if (!ref.current) {
      ref.current = { v: fn() };
    }
    return ref.current.v;
  }
  var __read = globalThis && globalThis.__read || function(o2, n2) {
    var m = typeof Symbol === "function" && o2[Symbol.iterator];
    if (!m)
      return o2;
    var i2 = m.call(o2), r2, ar = [], e2;
    try {
      while ((n2 === void 0 || n2-- > 0) && !(r2 = i2.next()).done)
        ar.push(r2.value);
    } catch (error) {
      e2 = { error };
    } finally {
      try {
        if (r2 && !r2.done && (m = i2["return"]))
          m.call(i2);
      } finally {
        if (e2)
          throw e2.error;
      }
    }
    return ar;
  };
  function identity(a2) {
    return a2;
  }
  var getServiceState = function(service) {
    var currentValue;
    service.subscribe(function(state) {
      currentValue = state;
    }).unsubscribe();
    return currentValue;
  };
  function useMachine(stateMachine, options) {
    var persistedStateRef = React.useRef();
    {
      var _a = __read(React.useState(stateMachine), 1), initialMachine = _a[0];
      if (stateMachine !== initialMachine) {
        console.warn("Machine given to `useMachine` has changed between renders. This is not supported and might lead to unexpected results.\nPlease make sure that you pass the same Machine as argument each time.");
      }
    }
    var _b = __read(useConstant(function() {
      var queue2 = [];
      var service2 = v(s(stateMachine.config, options ? options : stateMachine._options));
      var send = service2.send;
      service2.send = function(event) {
        if (service2.status === n.NotStarted) {
          queue2.push(event);
          return;
        }
        send(event);
        persistedStateRef.current = service2.state;
      };
      return [service2, queue2];
    }), 2), service = _b[0], queue = _b[1];
    index(function() {
      if (options) {
        service._machine._options = options;
      }
    });
    var useServiceResult = useService(service);
    React.useEffect(function() {
      service.start(persistedStateRef.current);
      queue.forEach(service.send);
      persistedStateRef.current = service.state;
      return function() {
        service.stop();
      };
    }, []);
    return useServiceResult;
  }
  var isEqual = function(_prevState, nextState) {
    return nextState.changed === false;
  };
  function useService(service) {
    var getSnapshot = React.useCallback(function() {
      return getServiceState(service);
    }, [service]);
    var subscribe = React.useCallback(function(handleStoreChange) {
      var unsubscribe = service.subscribe(handleStoreChange).unsubscribe;
      return unsubscribe;
    }, [service]);
    var storeSnapshot = withSelectorExports.useSyncExternalStoreWithSelector(subscribe, getSnapshot, getSnapshot, identity, isEqual);
    return [storeSnapshot, service.send, service];
  }
  function flattenConnection(connection) {
    if (!connection) {
      const noConnectionErr = `flattenConnection(): needs a 'connection' to flatten, but received '${connection ?? ""}' instead.`;
      {
        throw new Error(noConnectionErr);
      }
    }
    if ("nodes" in connection) {
      return connection.nodes;
    }
    if ("edges" in connection && Array.isArray(connection.edges)) {
      return connection.edges.map((edge) => {
        if (!(edge == null ? void 0 : edge.node)) {
          throw new Error(
            "flattenConnection(): Connection edges must contain nodes"
          );
        }
        return edge.node;
      });
    }
    {
      console.warn(
        `flattenConnection(): The connection did not contain either "nodes" or "edges.node". Returning an empty array.`
      );
    }
    return [];
  }
  const CartLineAdd = (cartFragment) => (
    /* GraphQL */
    `
  mutation CartLineAdd(
    $cartId: ID!
    $lines: [CartLineInput!]!
    $numCartLines: Int = 250
    $country: CountryCode = ZZ
  ) @inContext(country: $country) {
    cartLinesAdd(cartId: $cartId, lines: $lines) {
      cart {
        ...CartFragment
      }
    }
  }

  ${cartFragment}
`
  );
  const CartCreate = (cartFragment) => (
    /* GraphQL */
    `
  mutation CartCreate(
    $input: CartInput!
    $numCartLines: Int = 250
    $country: CountryCode = ZZ
  ) @inContext(country: $country) {
    cartCreate(input: $input) {
      cart {
        ...CartFragment
      }
    }
  }

  ${cartFragment}
`
  );
  const CartLineRemove = (cartFragment) => (
    /* GraphQL */
    `
  mutation CartLineRemove(
    $cartId: ID!
    $lines: [ID!]!
    $numCartLines: Int = 250
    $country: CountryCode = ZZ
  ) @inContext(country: $country) {
    cartLinesRemove(cartId: $cartId, lineIds: $lines) {
      cart {
        ...CartFragment
      }
    }
  }

  ${cartFragment}
`
  );
  const CartLineUpdate = (cartFragment) => (
    /* GraphQL */
    `
  mutation CartLineUpdate(
    $cartId: ID!
    $lines: [CartLineUpdateInput!]!
    $numCartLines: Int = 250
    $country: CountryCode = ZZ
  ) @inContext(country: $country) {
    cartLinesUpdate(cartId: $cartId, lines: $lines) {
      cart {
        ...CartFragment
      }
    }
  }

  ${cartFragment}
`
  );
  const CartNoteUpdate = (cartFragment) => (
    /* GraphQL */
    `
  mutation CartNoteUpdate(
    $cartId: ID!
    $note: String
    $numCartLines: Int = 250
    $country: CountryCode = ZZ
  ) @inContext(country: $country) {
    cartNoteUpdate(cartId: $cartId, note: $note) {
      cart {
        ...CartFragment
      }
    }
  }

  ${cartFragment}
`
  );
  const CartBuyerIdentityUpdate = (cartFragment) => (
    /* GraphQL */
    `
  mutation CartBuyerIdentityUpdate(
    $cartId: ID!
    $buyerIdentity: CartBuyerIdentityInput!
    $numCartLines: Int = 250
    $country: CountryCode = ZZ
  ) @inContext(country: $country) {
    cartBuyerIdentityUpdate(cartId: $cartId, buyerIdentity: $buyerIdentity) {
      cart {
        ...CartFragment
      }
    }
  }

  ${cartFragment}
`
  );
  const CartAttributesUpdate = (cartFragment) => (
    /* GraphQL */
    `
  mutation CartAttributesUpdate(
    $attributes: [AttributeInput!]!
    $cartId: ID!
    $numCartLines: Int = 250
    $country: CountryCode = ZZ
  ) @inContext(country: $country) {
    cartAttributesUpdate(attributes: $attributes, cartId: $cartId) {
      cart {
        ...CartFragment
      }
    }
  }

  ${cartFragment}
`
  );
  const CartDiscountCodesUpdate = (cartFragment) => (
    /* GraphQL */
    `
  mutation CartDiscountCodesUpdate(
    $cartId: ID!
    $discountCodes: [String!]
    $numCartLines: Int = 250
    $country: CountryCode = ZZ
  ) @inContext(country: $country) {
    cartDiscountCodesUpdate(cartId: $cartId, discountCodes: $discountCodes) {
      cart {
        ...CartFragment
      }
    }
  }

  ${cartFragment}
`
  );
  const CartQuery = (cartFragment) => (
    /* GraphQL */
    `
  query CartQuery(
    $id: ID!
    $numCartLines: Int = 250
    $country: CountryCode = ZZ
  ) @inContext(country: $country) {
    cart(id: $id) {
      ...CartFragment
    }
  }

  ${cartFragment}
`
  );
  const defaultCartFragment = (
    /* GraphQL */
    `
  fragment CartFragment on Cart {
    id
    checkoutUrl
    totalQuantity
    buyerIdentity {
      countryCode
      customer {
        id
        email
        firstName
        lastName
        displayName
      }
      email
      phone
    }
    lines(first: $numCartLines) {
      edges {
        node {
          id
          quantity
          attributes {
            key
            value
          }
          cost {
            totalAmount {
              amount
              currencyCode
            }
            compareAtAmountPerQuantity {
              amount
              currencyCode
            }
          }
          merchandise {
            ... on ProductVariant {
              id
              availableForSale
              compareAtPrice {
                ...MoneyFragment
              }
              price {
                ...MoneyFragment
              }
              requiresShipping
              title
              image {
                ...ImageFragment
              }
              product {
                handle
                title
                id
              }
              selectedOptions {
                name
                value
              }
            }
          }
        }
      }
    }
    cost {
      subtotalAmount {
        ...MoneyFragment
      }
      totalAmount {
        ...MoneyFragment
      }
      totalDutyAmount {
        ...MoneyFragment
      }
      totalTaxAmount {
        ...MoneyFragment
      }
    }
    note
    attributes {
      key
      value
    }
    discountCodes {
      code
    }
  }

  fragment MoneyFragment on MoneyV2 {
    currencyCode
    amount
  }
  fragment ImageFragment on Image {
    id
    url
    altText
    width
    height
  }
`
  );
  const SFAPI_VERSION = "2023-04";
  function createStorefrontClient(props) {
    const {
      storeDomain,
      privateStorefrontToken,
      publicStorefrontToken,
      storefrontApiVersion,
      contentType
    } = props;
    if (storefrontApiVersion !== SFAPI_VERSION) {
      warnOnce(
        `StorefrontClient: The Storefront API version that you're using is different than the version this build of Hydrogen React is targeting. You may run into unexpected errors if these versions don't match. Received verion: "${storefrontApiVersion}"; expected version "${SFAPI_VERSION}"`
      );
    }
    if (!privateStorefrontToken && !globalThis.document) {
      warnOnce(
        `StorefrontClient: Using a private storefront token is recommended for server environments. Refer to the authentication https://shopify.dev/api/storefront#authentication documentation for more details.`
      );
    }
    if (privateStorefrontToken && globalThis.document) {
      warnOnce(
        `StorefrontClient: You are attempting to use a private token in an environment where it can be easily accessed by anyone. This is a security risk; please use the public token and the 'publicStorefrontToken' prop`
      );
    }
    return {
      getShopifyDomain(overrideProps) {
        return (overrideProps == null ? void 0 : overrideProps.storeDomain) ?? storeDomain;
      },
      getStorefrontApiUrl(overrideProps) {
        const finalDomainUrl = (overrideProps == null ? void 0 : overrideProps.storeDomain) ?? storeDomain;
        return `${finalDomainUrl}${finalDomainUrl.endsWith("/") ? "" : "/"}api/${(overrideProps == null ? void 0 : overrideProps.storefrontApiVersion) ?? storefrontApiVersion}/graphql.json`;
      },
      getPrivateTokenHeaders(overrideProps) {
        if (!privateStorefrontToken && !(overrideProps == null ? void 0 : overrideProps.privateStorefrontToken)) {
          throw new Error(
            `StorefrontClient: You did not pass in a 'privateStorefrontToken' while using 'getPrivateTokenHeaders()'`
          );
        }
        if (!(overrideProps == null ? void 0 : overrideProps.buyerIp)) {
          warnOnce(
            `StorefrontClient: it is recommended to pass in the 'buyerIp' property which improves analytics and data in the admin.`
          );
        }
        const finalContentType = (overrideProps == null ? void 0 : overrideProps.contentType) ?? contentType;
        return {
          // default to json
          "content-type": finalContentType === "graphql" ? "application/graphql" : "application/json",
          "X-SDK-Variant": "hydrogen-react",
          "X-SDK-Variant-Source": "react",
          "X-SDK-Version": storefrontApiVersion,
          "Shopify-Storefront-Private-Token": (overrideProps == null ? void 0 : overrideProps.privateStorefrontToken) ?? privateStorefrontToken ?? "",
          ...(overrideProps == null ? void 0 : overrideProps.buyerIp) ? { "Shopify-Storefront-Buyer-IP": overrideProps.buyerIp } : {}
        };
      },
      getPublicTokenHeaders(overrideProps) {
        if (!publicStorefrontToken && !(overrideProps == null ? void 0 : overrideProps.publicStorefrontToken)) {
          throw new Error(
            `StorefrontClient: You did not pass in a 'publicStorefrontToken' while using 'getPublicTokenHeaders()'`
          );
        }
        const finalContentType = (overrideProps == null ? void 0 : overrideProps.contentType) ?? contentType ?? "json";
        return getPublicTokenHeadersRaw(
          finalContentType,
          storefrontApiVersion,
          (overrideProps == null ? void 0 : overrideProps.publicStorefrontToken) ?? publicStorefrontToken ?? ""
        );
      }
    };
  }
  function getPublicTokenHeadersRaw(contentType, storefrontApiVersion, accessToken) {
    return {
      // default to json
      "content-type": contentType === "graphql" ? "application/graphql" : "application/json",
      "X-SDK-Variant": "hydrogen-react",
      "X-SDK-Variant-Source": "react",
      "X-SDK-Version": storefrontApiVersion,
      "X-Shopify-Storefront-Access-Token": accessToken
    };
  }
  const warnings = /* @__PURE__ */ new Set();
  const warnOnce = (string) => {
    if (!warnings.has(string)) {
      console.warn(string);
      warnings.add(string);
    }
  };
  const defaultShopifyContext = {
    storeDomain: "test",
    storefrontToken: "abc123",
    storefrontApiVersion: SFAPI_VERSION,
    countryIsoCode: "US",
    languageIsoCode: "EN",
    getStorefrontApiUrl() {
      return "";
    },
    getPublicTokenHeaders() {
      return {};
    },
    getShopifyDomain() {
      return "";
    }
  };
  const ShopifyContext = React.createContext(
    defaultShopifyContext
  );
  function ShopifyProvider({
    children,
    ...shopifyConfig
  }) {
    if (!shopifyConfig.countryIsoCode || !shopifyConfig.languageIsoCode || !shopifyConfig.storeDomain || !shopifyConfig.storefrontToken || !shopifyConfig.storefrontApiVersion) {
      throw new Error(
        `Please provide the necessary props to '<ShopifyProvider/>'`
      );
    }
    if (shopifyConfig.storefrontApiVersion !== SFAPI_VERSION) {
      console.warn(
        `<ShopifyProvider/>: This version of Hydrogen React is built for Shopify's Storefront API version ${SFAPI_VERSION}, but it looks like you're using version ${shopifyConfig.storefrontApiVersion}. There may be issues or bugs if you use a mismatched version of Hydrogen React and the Storefront API.`
      );
    }
    const finalConfig = React.useMemo(() => {
      function getShopifyDomain(overrideProps) {
        return (overrideProps == null ? void 0 : overrideProps.storeDomain) ?? shopifyConfig.storeDomain;
      }
      return {
        ...shopifyConfig,
        getPublicTokenHeaders(overrideProps) {
          return getPublicTokenHeadersRaw(
            overrideProps.contentType,
            shopifyConfig.storefrontApiVersion,
            overrideProps.storefrontToken ?? shopifyConfig.storefrontToken
          );
        },
        getShopifyDomain,
        getStorefrontApiUrl(overrideProps) {
          const finalDomainUrl = getShopifyDomain({
            storeDomain: (overrideProps == null ? void 0 : overrideProps.storeDomain) ?? shopifyConfig.storeDomain
          });
          return `${finalDomainUrl}${finalDomainUrl.endsWith("/") ? "" : "/"}api/${(overrideProps == null ? void 0 : overrideProps.storefrontApiVersion) ?? shopifyConfig.storefrontApiVersion}/graphql.json`;
        }
      };
    }, [shopifyConfig]);
    return /* @__PURE__ */ React.createElement(ShopifyContext.Provider, { value: finalConfig }, children);
  }
  function useShop() {
    const shopContext = React.useContext(ShopifyContext);
    if (!shopContext) {
      throw new Error(`'useShop()' must be a descendent of <ShopifyProvider/>`);
    }
    return shopContext;
  }
  const CART_ID_STORAGE_KEY = "shopifyCartId";
  const SHOPIFY_STOREFRONT_ID_HEADER = "Shopify-Storefront-Id";
  const SHOPIFY_STOREFRONT_Y_HEADER = "Shopify-Storefront-Y";
  const SHOPIFY_STOREFRONT_S_HEADER = "Shopify-Storefront-S";
  const SHOPIFY_Y = "_shopify_y";
  const SHOPIFY_S = "_shopify_s";
  var g = /* @__PURE__ */ new Set([
    "domain",
    "path",
    "max-age",
    "expires",
    "samesite",
    "secure",
    "httponly"
  ]);
  function u(a2) {
    let r2 = {}, e2, t2, n2 = 0, m = a2.split(/;\s*/g), s2, i2;
    for (; n2 < m.length; n2++)
      if (t2 = m[n2], e2 = t2.indexOf("="), ~e2) {
        if (s2 = t2.substring(0, e2++).trim(), i2 = t2.substring(e2).trim(), i2[0] === '"' && (i2 = i2.substring(1, i2.length - 1)), ~i2.indexOf("%"))
          try {
            i2 = decodeURIComponent(i2);
          } catch (f2) {
          }
        g.has(t2 = s2.toLowerCase()) ? t2 === "expires" ? r2.expires = new Date(i2) : t2 === "max-age" ? r2.maxage = +i2 : r2[t2] = i2 : r2[s2] = i2;
      } else
        (s2 = t2.trim().toLowerCase()) && (s2 === "httponly" || s2 === "secure") && (r2[s2] = true);
    return r2;
  }
  function l(a2, r2, e2 = {}) {
    let t2 = a2 + "=" + encodeURIComponent(r2);
    return e2.expires && (t2 += "; Expires=" + new Date(e2.expires).toUTCString()), e2.maxage != null && e2.maxage >= 0 && (t2 += "; Max-Age=" + (e2.maxage | 0)), e2.domain && (t2 += "; Domain=" + e2.domain), e2.path && (t2 += "; Path=" + e2.path), e2.samesite && (t2 += "; SameSite=" + e2.samesite), (e2.secure || e2.samesite === "None") && (t2 += "; Secure"), e2.httponly && (t2 += "; HttpOnly"), t2;
  }
  const tokenHash = "xxxx-4xxx-xxxx-xxxxxxxxxxxx";
  function buildUUID() {
    let hash = "";
    try {
      const crypto = window.crypto;
      const randomValuesArray = new Uint16Array(31);
      crypto.getRandomValues(randomValuesArray);
      let i2 = 0;
      hash = tokenHash.replace(/[x]/g, (c2) => {
        const r2 = randomValuesArray[i2] % 16;
        const v2 = c2 === "x" ? r2 : r2 & 3 | 8;
        i2++;
        return v2.toString(16);
      }).toUpperCase();
    } catch (err) {
      hash = tokenHash.replace(/[x]/g, (c2) => {
        const r2 = Math.random() * 16 | 0;
        const v2 = c2 === "x" ? r2 : r2 & 3 | 8;
        return v2.toString(16);
      }).toUpperCase();
    }
    return `${hexTime()}-${hash}`;
  }
  function hexTime() {
    let dateNumber = 0;
    let perfNumber = 0;
    dateNumber = new Date().getTime() >>> 0;
    try {
      perfNumber = performance.now() >>> 0;
    } catch (err) {
      perfNumber = 0;
    }
    const output = Math.abs(dateNumber + perfNumber).toString(16).toLowerCase();
    return output.padStart(8 - output.length, "0");
  }
  function getShopifyCookies(cookies) {
    const cookieData = u(cookies);
    return {
      [SHOPIFY_Y]: cookieData[SHOPIFY_Y] || "",
      [SHOPIFY_S]: cookieData[SHOPIFY_S] || ""
    };
  }
  function useCartFetch() {
    const { storefrontId, getPublicTokenHeaders, getStorefrontApiUrl } = useShop();
    return React.useCallback(
      ({
        query,
        variables
      }) => {
        const headers = getPublicTokenHeaders({ contentType: "json" });
        if (storefrontId) {
          headers[SHOPIFY_STOREFRONT_ID_HEADER] = storefrontId;
        }
        const cookieData = getShopifyCookies(document.cookie);
        headers[SHOPIFY_STOREFRONT_Y_HEADER] = cookieData[SHOPIFY_Y];
        headers[SHOPIFY_STOREFRONT_S_HEADER] = cookieData[SHOPIFY_S];
        return fetch(getStorefrontApiUrl(), {
          method: "POST",
          headers,
          body: JSON.stringify({
            query: query.toString(),
            variables
          })
        }).then(
          (res) => res.json()
        ).catch((error) => {
          return {
            data: void 0,
            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-unsafe-call
            errors: error == null ? void 0 : error.toString()
          };
        });
      },
      [getPublicTokenHeaders, storefrontId, getStorefrontApiUrl]
    );
  }
  function useCartActions({
    numCartLines,
    cartFragment,
    countryCode = "US"
  }) {
    const fetchCart = useCartFetch();
    const cartFetch = React.useCallback(
      (cartId) => {
        return fetchCart({
          query: CartQuery(cartFragment),
          variables: {
            id: cartId,
            numCartLines,
            country: countryCode
          }
        });
      },
      [fetchCart, cartFragment, numCartLines, countryCode]
    );
    const cartCreate = React.useCallback(
      (cart) => {
        return fetchCart({
          query: CartCreate(cartFragment),
          variables: {
            input: cart,
            numCartLines,
            country: countryCode
          }
        });
      },
      [cartFragment, countryCode, fetchCart, numCartLines]
    );
    const cartLineAdd = React.useCallback(
      (cartId, lines) => {
        return fetchCart({
          query: CartLineAdd(cartFragment),
          variables: {
            cartId,
            lines,
            numCartLines,
            country: countryCode
          }
        });
      },
      [cartFragment, countryCode, fetchCart, numCartLines]
    );
    const cartLineUpdate = React.useCallback(
      (cartId, lines) => {
        return fetchCart({
          query: CartLineUpdate(cartFragment),
          variables: {
            cartId,
            lines,
            numCartLines,
            country: countryCode
          }
        });
      },
      [cartFragment, countryCode, fetchCart, numCartLines]
    );
    const cartLineRemove = React.useCallback(
      (cartId, lines) => {
        return fetchCart({
          query: CartLineRemove(cartFragment),
          variables: {
            cartId,
            lines,
            numCartLines,
            country: countryCode
          }
        });
      },
      [cartFragment, countryCode, fetchCart, numCartLines]
    );
    const noteUpdate = React.useCallback(
      (cartId, note) => {
        return fetchCart({
          query: CartNoteUpdate(cartFragment),
          variables: {
            cartId,
            note,
            numCartLines,
            country: countryCode
          }
        });
      },
      [fetchCart, cartFragment, numCartLines, countryCode]
    );
    const buyerIdentityUpdate = React.useCallback(
      (cartId, buyerIdentity) => {
        return fetchCart({
          query: CartBuyerIdentityUpdate(cartFragment),
          variables: {
            cartId,
            buyerIdentity,
            numCartLines,
            country: countryCode
          }
        });
      },
      [cartFragment, countryCode, fetchCart, numCartLines]
    );
    const cartAttributesUpdate = React.useCallback(
      (cartId, attributes) => {
        return fetchCart({
          query: CartAttributesUpdate(cartFragment),
          variables: {
            cartId,
            attributes,
            numCartLines,
            country: countryCode
          }
        });
      },
      [cartFragment, countryCode, fetchCart, numCartLines]
    );
    const discountCodesUpdate = React.useCallback(
      (cartId, discountCodes) => {
        return fetchCart({
          query: CartDiscountCodesUpdate(cartFragment),
          variables: {
            cartId,
            discountCodes,
            numCartLines,
            country: countryCode
          }
        });
      },
      [cartFragment, countryCode, fetchCart, numCartLines]
    );
    return React.useMemo(
      () => ({
        cartFetch,
        cartCreate,
        cartLineAdd,
        cartLineUpdate,
        cartLineRemove,
        noteUpdate,
        buyerIdentityUpdate,
        cartAttributesUpdate,
        discountCodesUpdate,
        cartFragment
      }),
      [
        cartFetch,
        cartCreate,
        cartLineAdd,
        cartLineUpdate,
        cartLineRemove,
        noteUpdate,
        buyerIdentityUpdate,
        cartAttributesUpdate,
        discountCodesUpdate,
        cartFragment
      ]
    );
  }
  function invokeCart(action, options) {
    return {
      entry: [
        ...(options == null ? void 0 : options.entryActions) || [],
        i({
          lastValidCart: (context) => context == null ? void 0 : context.cart
        }),
        "onCartActionEntry",
        "onCartActionOptimisticUI",
        action
      ],
      on: {
        RESOLVE: {
          target: (options == null ? void 0 : options.resolveTarget) || "idle",
          actions: [
            i({
              prevCart: (context) => context == null ? void 0 : context.lastValidCart,
              cart: (_, event) => {
                var _a;
                return (_a = event == null ? void 0 : event.payload) == null ? void 0 : _a.cart;
              },
              rawCartResult: (_, event) => {
                var _a;
                return (_a = event == null ? void 0 : event.payload) == null ? void 0 : _a.rawCartResult;
              },
              // eslint-disable-next-line @typescript-eslint/no-unused-vars
              errors: (_) => void 0
            })
          ]
        },
        ERROR: {
          target: (options == null ? void 0 : options.errorTarget) || "error",
          actions: [
            i({
              prevCart: (context) => context == null ? void 0 : context.lastValidCart,
              cart: (context) => context == null ? void 0 : context.lastValidCart,
              errors: (_, event) => {
                var _a;
                return (_a = event == null ? void 0 : event.payload) == null ? void 0 : _a.errors;
              }
            })
          ]
        },
        CART_COMPLETED: {
          target: "cartCompleted",
          actions: i({
            // eslint-disable-next-line @typescript-eslint/no-unused-vars
            prevCart: (_) => void 0,
            // eslint-disable-next-line @typescript-eslint/no-unused-vars
            cart: (_) => void 0,
            // eslint-disable-next-line @typescript-eslint/no-unused-vars
            lastValidCart: (_) => void 0,
            // eslint-disable-next-line @typescript-eslint/no-unused-vars
            rawCartResult: (_) => void 0,
            // eslint-disable-next-line @typescript-eslint/no-unused-vars
            errors: (_) => void 0
          })
        }
      },
      exit: ["onCartActionComplete", ...(options == null ? void 0 : options.exitActions) || []]
    };
  }
  const INITIALIZING_CART_EVENTS = {
    CART_FETCH: {
      target: "cartFetching"
    },
    CART_CREATE: {
      target: "cartCreating"
    },
    CART_SET: {
      target: "idle",
      actions: [
        i({
          rawCartResult: (_, event) => event.payload.cart,
          cart: (_, event) => cartFromGraphQL(event.payload.cart)
        })
      ]
    }
  };
  const UPDATING_CART_EVENTS = {
    CARTLINE_ADD: {
      target: "cartLineAdding"
    },
    CARTLINE_UPDATE: {
      target: "cartLineUpdating"
    },
    CARTLINE_REMOVE: {
      target: "cartLineRemoving"
    },
    NOTE_UPDATE: {
      target: "noteUpdating"
    },
    BUYER_IDENTITY_UPDATE: {
      target: "buyerIdentityUpdating"
    },
    CART_ATTRIBUTES_UPDATE: {
      target: "cartAttributesUpdating"
    },
    DISCOUNT_CODES_UPDATE: {
      target: "discountCodesUpdating"
    }
  };
  function createCartMachine(initialCart) {
    return s({
      id: "Cart",
      initial: initialCart ? "idle" : "uninitialized",
      context: {
        cart: initialCart && cartFromGraphQL(initialCart)
      },
      states: {
        uninitialized: {
          on: INITIALIZING_CART_EVENTS
        },
        cartCompleted: {
          on: INITIALIZING_CART_EVENTS
        },
        initializationError: {
          on: INITIALIZING_CART_EVENTS
        },
        idle: {
          on: { ...INITIALIZING_CART_EVENTS, ...UPDATING_CART_EVENTS }
        },
        error: {
          on: { ...INITIALIZING_CART_EVENTS, ...UPDATING_CART_EVENTS }
        },
        cartFetching: invokeCart("cartFetchAction", {
          errorTarget: "initializationError"
        }),
        cartCreating: invokeCart("cartCreateAction", {
          errorTarget: "initializationError"
        }),
        cartLineRemoving: invokeCart("cartLineRemoveAction"),
        cartLineUpdating: invokeCart("cartLineUpdateAction"),
        cartLineAdding: invokeCart("cartLineAddAction"),
        noteUpdating: invokeCart("noteUpdateAction"),
        buyerIdentityUpdating: invokeCart("buyerIdentityUpdateAction"),
        cartAttributesUpdating: invokeCart("cartAttributesUpdateAction"),
        discountCodesUpdating: invokeCart("discountCodesUpdateAction")
      }
    });
  }
  function useCartAPIStateMachine({
    numCartLines,
    onCartActionEntry,
    onCartActionOptimisticUI,
    onCartActionComplete,
    data: cart,
    cartFragment,
    countryCode
  }) {
    const {
      cartFetch,
      cartCreate,
      cartLineAdd,
      cartLineUpdate,
      cartLineRemove,
      noteUpdate,
      buyerIdentityUpdate,
      cartAttributesUpdate,
      discountCodesUpdate
    } = useCartActions({
      numCartLines,
      cartFragment,
      countryCode
    });
    const cartMachine = React.useMemo(() => createCartMachine(cart), [cart]);
    const [state, send, service] = useMachine(cartMachine, {
      actions: {
        // eslint-disable-next-line @typescript-eslint/no-misused-promises
        cartFetchAction: async (_, event) => {
          var _a;
          if (event.type !== "CART_FETCH")
            return;
          const { data, errors } = await cartFetch((_a = event == null ? void 0 : event.payload) == null ? void 0 : _a.cartId);
          const resultEvent = eventFromFetchResult(event, data == null ? void 0 : data.cart, errors);
          send(resultEvent);
        },
        // eslint-disable-next-line @typescript-eslint/no-misused-promises
        cartCreateAction: async (_, event) => {
          var _a;
          if (event.type !== "CART_CREATE")
            return;
          const { data, errors } = await cartCreate(event == null ? void 0 : event.payload);
          const resultEvent = eventFromFetchResult(
            event,
            (_a = data == null ? void 0 : data.cartCreate) == null ? void 0 : _a.cart,
            errors
          );
          send(resultEvent);
        },
        // eslint-disable-next-line @typescript-eslint/no-misused-promises
        cartLineAddAction: async (context, event) => {
          var _a, _b;
          if (event.type !== "CARTLINE_ADD" || !((_a = context == null ? void 0 : context.cart) == null ? void 0 : _a.id))
            return;
          const { data, errors } = await cartLineAdd(
            context.cart.id,
            event.payload.lines
          );
          const resultEvent = eventFromFetchResult(
            event,
            (_b = data == null ? void 0 : data.cartLinesAdd) == null ? void 0 : _b.cart,
            errors
          );
          send(resultEvent);
        },
        // eslint-disable-next-line @typescript-eslint/no-misused-promises
        cartLineUpdateAction: async (context, event) => {
          var _a, _b;
          if (event.type !== "CARTLINE_UPDATE" || !((_a = context == null ? void 0 : context.cart) == null ? void 0 : _a.id))
            return;
          const { data, errors } = await cartLineUpdate(
            context.cart.id,
            event.payload.lines
          );
          const resultEvent = eventFromFetchResult(
            event,
            (_b = data == null ? void 0 : data.cartLinesUpdate) == null ? void 0 : _b.cart,
            errors
          );
          send(resultEvent);
        },
        // eslint-disable-next-line @typescript-eslint/no-misused-promises
        cartLineRemoveAction: async (context, event) => {
          var _a, _b;
          if (event.type !== "CARTLINE_REMOVE" || !((_a = context == null ? void 0 : context.cart) == null ? void 0 : _a.id))
            return;
          const { data, errors } = await cartLineRemove(
            context.cart.id,
            event.payload.lines
          );
          const resultEvent = eventFromFetchResult(
            event,
            (_b = data == null ? void 0 : data.cartLinesRemove) == null ? void 0 : _b.cart,
            errors
          );
          send(resultEvent);
        },
        // eslint-disable-next-line @typescript-eslint/no-misused-promises
        noteUpdateAction: async (context, event) => {
          var _a, _b;
          if (event.type !== "NOTE_UPDATE" || !((_a = context == null ? void 0 : context.cart) == null ? void 0 : _a.id))
            return;
          const { data, errors } = await noteUpdate(
            context.cart.id,
            event.payload.note
          );
          const resultEvent = eventFromFetchResult(
            event,
            (_b = data == null ? void 0 : data.cartNoteUpdate) == null ? void 0 : _b.cart,
            errors
          );
          send(resultEvent);
        },
        // eslint-disable-next-line @typescript-eslint/no-misused-promises
        buyerIdentityUpdateAction: async (context, event) => {
          var _a, _b;
          if (event.type !== "BUYER_IDENTITY_UPDATE" || !((_a = context == null ? void 0 : context.cart) == null ? void 0 : _a.id))
            return;
          const { data, errors } = await buyerIdentityUpdate(
            context.cart.id,
            event.payload.buyerIdentity
          );
          const resultEvent = eventFromFetchResult(
            event,
            (_b = data == null ? void 0 : data.cartBuyerIdentityUpdate) == null ? void 0 : _b.cart,
            errors
          );
          send(resultEvent);
        },
        // eslint-disable-next-line @typescript-eslint/no-misused-promises
        cartAttributesUpdateAction: async (context, event) => {
          var _a, _b;
          if (event.type !== "CART_ATTRIBUTES_UPDATE" || !((_a = context == null ? void 0 : context.cart) == null ? void 0 : _a.id))
            return;
          const { data, errors } = await cartAttributesUpdate(
            context.cart.id,
            event.payload.attributes
          );
          const resultEvent = eventFromFetchResult(
            event,
            (_b = data == null ? void 0 : data.cartAttributesUpdate) == null ? void 0 : _b.cart,
            errors
          );
          send(resultEvent);
        },
        // eslint-disable-next-line @typescript-eslint/no-misused-promises
        discountCodesUpdateAction: async (context, event) => {
          var _a, _b;
          if (event.type !== "DISCOUNT_CODES_UPDATE" || !((_a = context == null ? void 0 : context.cart) == null ? void 0 : _a.id))
            return;
          const { data, errors } = await discountCodesUpdate(
            context.cart.id,
            event.payload.discountCodes
          );
          const resultEvent = eventFromFetchResult(
            event,
            (_b = data == null ? void 0 : data.cartDiscountCodesUpdate) == null ? void 0 : _b.cart,
            errors
          );
          send(resultEvent);
        },
        ...onCartActionEntry && {
          onCartActionEntry: (context, event) => {
            if (isCartActionEvent(event)) {
              onCartActionEntry(context, event);
            }
          }
        },
        ...onCartActionOptimisticUI && {
          onCartActionOptimisticUI: i((context, event) => {
            return onCartActionOptimisticUI(context, event);
          })
        },
        ...onCartActionComplete && {
          onCartActionComplete: (context, event) => {
            if (isCartFetchResultEvent(event)) {
              onCartActionComplete(context, event);
            }
          }
        }
      }
    });
    return React.useMemo(() => [state, send, service], [state, send, service]);
  }
  function cartFromGraphQL(cart) {
    return {
      ...cart,
      lines: flattenConnection(cart == null ? void 0 : cart.lines),
      note: cart.note ?? void 0
    };
  }
  function eventFromFetchResult(cartActionEvent, cart, errors) {
    if (errors) {
      return { type: "ERROR", payload: { errors, cartActionEvent } };
    }
    if (!cart) {
      return {
        type: "CART_COMPLETED",
        payload: {
          cartActionEvent
        }
      };
    }
    return {
      type: "RESOLVE",
      payload: {
        cart: cartFromGraphQL(cart),
        rawCartResult: cart,
        cartActionEvent
      }
    };
  }
  function isCartActionEvent(event) {
    return event.type === "CART_CREATE" || event.type === "CARTLINE_ADD" || event.type === "CARTLINE_UPDATE" || event.type === "CARTLINE_REMOVE" || event.type === "NOTE_UPDATE" || event.type === "BUYER_IDENTITY_UPDATE" || event.type === "CART_ATTRIBUTES_UPDATE" || event.type === "DISCOUNT_CODES_UPDATE";
  }
  function isCartFetchResultEvent(event) {
    return event.type === "RESOLVE" || event.type === "ERROR" || event.type === "CART_COMPLETED";
  }
  const CartContext = React.createContext(null);
  function useCart() {
    const context = React.useContext(CartContext);
    if (!context) {
      throw new Error("Expected a Cart Context, but no Cart Context was found");
    }
    return context;
  }
  function CartProvider({
    children,
    numCartLines,
    onCreate,
    onLineAdd,
    onLineRemove,
    onLineUpdate,
    onNoteUpdate,
    onBuyerIdentityUpdate,
    onAttributesUpdate,
    onDiscountCodesUpdate,
    onCreateComplete,
    onLineAddComplete,
    onLineRemoveComplete,
    onLineUpdateComplete,
    onNoteUpdateComplete,
    onBuyerIdentityUpdateComplete,
    onAttributesUpdateComplete,
    onDiscountCodesUpdateComplete,
    data: cart,
    cartFragment = defaultCartFragment,
    customerAccessToken,
    countryCode = "US"
  }) {
    var _a, _b, _c, _d, _e, _f, _g;
    if (countryCode)
      countryCode = countryCode.toUpperCase();
    const [prevCountryCode, setPrevCountryCode] = React.useState(countryCode);
    const [prevCustomerAccessToken, setPrevCustomerAccessToken] = React.useState(customerAccessToken);
    const customerOverridesCountryCode = React.useRef(false);
    if (prevCountryCode !== countryCode || prevCustomerAccessToken !== customerAccessToken) {
      setPrevCountryCode(countryCode);
      setPrevCustomerAccessToken(customerAccessToken);
      customerOverridesCountryCode.current = false;
    }
    const [cartState, cartSend] = useCartAPIStateMachine({
      numCartLines,
      data: cart,
      cartFragment,
      countryCode,
      onCartActionEntry(_, event) {
        try {
          switch (event.type) {
            case "CART_CREATE":
              return onCreate == null ? void 0 : onCreate();
            case "CARTLINE_ADD":
              return onLineAdd == null ? void 0 : onLineAdd();
            case "CARTLINE_REMOVE":
              return onLineRemove == null ? void 0 : onLineRemove();
            case "CARTLINE_UPDATE":
              return onLineUpdate == null ? void 0 : onLineUpdate();
            case "NOTE_UPDATE":
              return onNoteUpdate == null ? void 0 : onNoteUpdate();
            case "BUYER_IDENTITY_UPDATE":
              return onBuyerIdentityUpdate == null ? void 0 : onBuyerIdentityUpdate();
            case "CART_ATTRIBUTES_UPDATE":
              return onAttributesUpdate == null ? void 0 : onAttributesUpdate();
            case "DISCOUNT_CODES_UPDATE":
              return onDiscountCodesUpdate == null ? void 0 : onDiscountCodesUpdate();
          }
        } catch (error) {
          console.error("Cart entry action failed", error);
        }
      },
      onCartActionOptimisticUI(context, event) {
        var _a2, _b2, _c2, _d2;
        if (!context.cart)
          return { ...context };
        switch (event.type) {
          case "CARTLINE_REMOVE":
            return {
              ...context,
              cart: {
                ...context.cart,
                lines: (_b2 = (_a2 = context == null ? void 0 : context.cart) == null ? void 0 : _a2.lines) == null ? void 0 : _b2.filter(
                  (line) => (line == null ? void 0 : line.id) && !event.payload.lines.includes(line == null ? void 0 : line.id)
                )
              }
            };
          case "CARTLINE_UPDATE":
            return {
              ...context,
              cart: {
                ...context.cart,
                lines: (_d2 = (_c2 = context == null ? void 0 : context.cart) == null ? void 0 : _c2.lines) == null ? void 0 : _d2.map((line) => {
                  const updatedLine = event.payload.lines.find(
                    ({ id }) => id === (line == null ? void 0 : line.id)
                  );
                  if (updatedLine && updatedLine.quantity) {
                    return {
                      ...line,
                      quantity: updatedLine.quantity
                    };
                  }
                  return line;
                })
              }
            };
        }
        return { ...context };
      },
      onCartActionComplete(context, event) {
        const cartActionEvent = event.payload.cartActionEvent;
        try {
          switch (event.type) {
            case "RESOLVE":
              switch (cartActionEvent.type) {
                case "CART_CREATE":
                  return onCreateComplete == null ? void 0 : onCreateComplete();
                case "CARTLINE_ADD":
                  return onLineAddComplete == null ? void 0 : onLineAddComplete();
                case "CARTLINE_REMOVE":
                  return onLineRemoveComplete == null ? void 0 : onLineRemoveComplete();
                case "CARTLINE_UPDATE":
                  return onLineUpdateComplete == null ? void 0 : onLineUpdateComplete();
                case "NOTE_UPDATE":
                  return onNoteUpdateComplete == null ? void 0 : onNoteUpdateComplete();
                case "BUYER_IDENTITY_UPDATE":
                  if (countryCodeNotUpdated(context, cartActionEvent)) {
                    customerOverridesCountryCode.current = true;
                  }
                  return onBuyerIdentityUpdateComplete == null ? void 0 : onBuyerIdentityUpdateComplete();
                case "CART_ATTRIBUTES_UPDATE":
                  return onAttributesUpdateComplete == null ? void 0 : onAttributesUpdateComplete();
                case "DISCOUNT_CODES_UPDATE":
                  return onDiscountCodesUpdateComplete == null ? void 0 : onDiscountCodesUpdateComplete();
              }
          }
        } catch (error) {
          console.error("onCartActionComplete failed", error);
        }
      }
    });
    const cartReady = React.useRef(false);
    const cartCompleted = cartState.matches("cartCompleted");
    const countryChanged = (cartState.value === "idle" || cartState.value === "error" || cartState.value === "cartCompleted") && countryCode !== ((_c = (_b = (_a = cartState == null ? void 0 : cartState.context) == null ? void 0 : _a.cart) == null ? void 0 : _b.buyerIdentity) == null ? void 0 : _c.countryCode) && !cartState.context.errors;
    const fetchingFromStorage = React.useRef(false);
    React.useEffect(() => {
      if (!cartReady.current && !fetchingFromStorage.current) {
        if (!cart && storageAvailable("localStorage")) {
          fetchingFromStorage.current = true;
          try {
            const cartId = window.localStorage.getItem(CART_ID_STORAGE_KEY);
            if (cartId) {
              cartSend({ type: "CART_FETCH", payload: { cartId } });
            }
          } catch (error) {
            console.warn("error fetching cartId");
            console.warn(error);
          }
        }
        cartReady.current = true;
      }
    }, [cart, cartReady, cartSend]);
    React.useEffect(() => {
      if (!countryChanged || customerOverridesCountryCode.current)
        return;
      cartSend({
        type: "BUYER_IDENTITY_UPDATE",
        payload: { buyerIdentity: { countryCode, customerAccessToken } }
      });
    }, [
      countryCode,
      customerAccessToken,
      countryChanged,
      customerOverridesCountryCode,
      cartSend
    ]);
    const onCartReadySend = React.useCallback(
      (cartEvent) => {
        if (!cartReady.current) {
          return console.warn("Cart isn't ready yet");
        }
        cartSend(cartEvent);
      },
      [cartSend]
    );
    React.useEffect(() => {
      var _a2, _b2, _c2;
      if (((_b2 = (_a2 = cartState == null ? void 0 : cartState.context) == null ? void 0 : _a2.cart) == null ? void 0 : _b2.id) && storageAvailable("localStorage")) {
        try {
          window.localStorage.setItem(
            CART_ID_STORAGE_KEY,
            (_c2 = cartState.context.cart) == null ? void 0 : _c2.id
          );
        } catch (error) {
          console.warn("Failed to save cartId to localStorage", error);
        }
      }
    }, [(_e = (_d = cartState == null ? void 0 : cartState.context) == null ? void 0 : _d.cart) == null ? void 0 : _e.id]);
    React.useEffect(() => {
      if (cartCompleted && storageAvailable("localStorage")) {
        try {
          window.localStorage.removeItem(CART_ID_STORAGE_KEY);
        } catch (error) {
          console.warn("Failed to delete cartId from localStorage", error);
        }
      }
    }, [cartCompleted]);
    const cartCreate = React.useCallback(
      (cartInput) => {
        var _a2, _b2;
        if (countryCode && !((_a2 = cartInput.buyerIdentity) == null ? void 0 : _a2.countryCode)) {
          if (cartInput.buyerIdentity == null) {
            cartInput.buyerIdentity = {};
          }
          cartInput.buyerIdentity.countryCode = countryCode;
        }
        if (customerAccessToken && !((_b2 = cartInput.buyerIdentity) == null ? void 0 : _b2.customerAccessToken)) {
          if (cartInput.buyerIdentity == null) {
            cartInput.buyerIdentity = {};
          }
          cartInput.buyerIdentity.customerAccessToken = customerAccessToken;
        }
        onCartReadySend({
          type: "CART_CREATE",
          payload: cartInput
        });
      },
      [countryCode, customerAccessToken, onCartReadySend]
    );
    const cartDisplayState = useDelayedStateUntilHydration(cartState);
    const cartContextValue = React.useMemo(() => {
      var _a2, _b2, _c2, _d2;
      return {
        ...((_a2 = cartDisplayState == null ? void 0 : cartDisplayState.context) == null ? void 0 : _a2.cart) ?? { lines: [], attributes: [] },
        status: transposeStatus(cartDisplayState.value),
        error: (_b2 = cartDisplayState == null ? void 0 : cartDisplayState.context) == null ? void 0 : _b2.errors,
        totalQuantity: ((_d2 = (_c2 = cartDisplayState == null ? void 0 : cartDisplayState.context) == null ? void 0 : _c2.cart) == null ? void 0 : _d2.totalQuantity) ?? 0,
        cartCreate,
        linesAdd(lines) {
          var _a3, _b3;
          if ((_b3 = (_a3 = cartDisplayState == null ? void 0 : cartDisplayState.context) == null ? void 0 : _a3.cart) == null ? void 0 : _b3.id) {
            onCartReadySend({
              type: "CARTLINE_ADD",
              payload: { lines }
            });
          } else {
            cartCreate({ lines });
          }
        },
        linesRemove(lines) {
          onCartReadySend({
            type: "CARTLINE_REMOVE",
            payload: {
              lines
            }
          });
        },
        linesUpdate(lines) {
          onCartReadySend({
            type: "CARTLINE_UPDATE",
            payload: {
              lines
            }
          });
        },
        noteUpdate(note) {
          onCartReadySend({
            type: "NOTE_UPDATE",
            payload: {
              note
            }
          });
        },
        buyerIdentityUpdate(buyerIdentity) {
          onCartReadySend({
            type: "BUYER_IDENTITY_UPDATE",
            payload: {
              buyerIdentity
            }
          });
        },
        cartAttributesUpdate(attributes) {
          onCartReadySend({
            type: "CART_ATTRIBUTES_UPDATE",
            payload: {
              attributes
            }
          });
        },
        discountCodesUpdate(discountCodes) {
          onCartReadySend({
            type: "DISCOUNT_CODES_UPDATE",
            payload: {
              discountCodes
            }
          });
        },
        cartFragment
      };
    }, [
      cartCreate,
      (_f = cartDisplayState == null ? void 0 : cartDisplayState.context) == null ? void 0 : _f.cart,
      (_g = cartDisplayState == null ? void 0 : cartDisplayState.context) == null ? void 0 : _g.errors,
      cartDisplayState.value,
      cartFragment,
      onCartReadySend
    ]);
    return /* @__PURE__ */ React.createElement(CartContext.Provider, { value: cartContextValue }, children);
  }
  function transposeStatus(status) {
    switch (status) {
      case "uninitialized":
      case "initializationError":
        return "uninitialized";
      case "idle":
      case "cartCompleted":
      case "error":
        return "idle";
      case "cartFetching":
        return "fetching";
      case "cartCreating":
        return "creating";
      case "cartLineAdding":
      case "cartLineRemoving":
      case "cartLineUpdating":
      case "noteUpdating":
      case "buyerIdentityUpdating":
      case "cartAttributesUpdating":
      case "discountCodesUpdating":
        return "updating";
    }
  }
  function useDelayedStateUntilHydration(state) {
    const [isPending, startTransition] = React.useTransition();
    const [delayedState, setDelayedState] = React.useState(state);
    const firstTimePending = React.useRef(false);
    if (isPending) {
      firstTimePending.current = true;
    }
    const firstTimePendingFinished = React.useRef(false);
    if (!isPending && firstTimePending.current) {
      firstTimePendingFinished.current = true;
    }
    React.useEffect(() => {
      startTransition(() => {
        if (!firstTimePendingFinished.current) {
          setDelayedState(state);
        }
      });
    }, [state]);
    const displayState = firstTimePendingFinished.current ? state : delayedState;
    return displayState;
  }
  function storageAvailable(type) {
    let storage;
    try {
      storage = window[type];
      const x = "__storage_test__";
      storage.setItem(x, x);
      storage.removeItem(x);
      return true;
    } catch (e2) {
      return !!(e2 instanceof DOMException && // everything except Firefox
      (e2.code === 22 || // Firefox
      e2.code === 1014 || // test name field too, because code might not be present
      // everything except Firefox
      e2.name === "QuotaExceededError" || // Firefox
      e2.name === "NS_ERROR_DOM_QUOTA_REACHED") && // acknowledge QuotaExceededError only if there's something already stored
      storage && storage.length !== 0);
    }
  }
  function countryCodeNotUpdated(context, event) {
    var _a, _b;
    return !!(event.payload.buyerIdentity.countryCode && ((_b = (_a = context.cart) == null ? void 0 : _a.buyerIdentity) == null ? void 0 : _b.countryCode) !== event.payload.buyerIdentity.countryCode);
  }
  const ProductOptionsContext = React.createContext(null);
  function ProductProvider({
    children,
    data: product,
    initialVariantId: explicitVariantId
  }) {
    const variants = React.useMemo(
      () => flattenConnection(product.variants ?? {}),
      [product.variants]
    );
    if (!isProductVariantArray(variants)) {
      throw new Error(
        `<ProductProvider/> requires 'product.variants.nodes' or 'product.variants.edges'`
      );
    }
    const options = React.useMemo(() => getOptions(variants), [variants]);
    const [selectedVariant, setSelectedVariant] = React.useState(() => getVariantBasedOnIdProp(explicitVariantId, variants));
    const [selectedOptions, setSelectedOptions] = React.useState(
      () => getSelectedOptions(selectedVariant)
    );
    React.useEffect(() => {
      const newSelectedVariant = getVariantBasedOnIdProp(
        explicitVariantId,
        variants
      );
      setSelectedVariant(newSelectedVariant);
      setSelectedOptions(getSelectedOptions(newSelectedVariant));
    }, [explicitVariantId, variants]);
    const setSelectedOption = React.useCallback(
      (name, value2) => {
        setSelectedOptions((selectedOptions2) => {
          const opts = { ...selectedOptions2, [name]: value2 };
          setSelectedVariant(getSelectedVariant(variants, opts));
          return opts;
        });
      },
      [setSelectedOptions, variants]
    );
    const isOptionInStock = React.useCallback(
      (option, value2) => {
        const proposedVariant = getSelectedVariant(variants, {
          ...selectedOptions,
          ...{ [option]: value2 }
        });
        return (proposedVariant == null ? void 0 : proposedVariant.availableForSale) ?? true;
      },
      [selectedOptions, variants]
    );
    const sellingPlanGroups = React.useMemo(
      () => flattenConnection(product.sellingPlanGroups ?? {}).map(
        (sellingPlanGroup) => ({
          ...sellingPlanGroup,
          sellingPlans: flattenConnection((sellingPlanGroup == null ? void 0 : sellingPlanGroup.sellingPlans) ?? {})
        })
      ),
      [product.sellingPlanGroups]
    );
    const [selectedSellingPlan, setSelectedSellingPlan] = React.useState(void 0);
    const selectedSellingPlanAllocation = React.useMemo(() => {
      var _a, _b;
      if (!selectedVariant || !selectedSellingPlan) {
        return;
      }
      if (!((_a = selectedVariant.sellingPlanAllocations) == null ? void 0 : _a.nodes) && !((_b = selectedVariant.sellingPlanAllocations) == null ? void 0 : _b.edges)) {
        throw new Error(
          `<ProductProvider/>: You must include 'sellingPlanAllocations.nodes' or 'sellingPlanAllocations.edges' in your variants in order to calculate selectedSellingPlanAllocation`
        );
      }
      return flattenConnection(selectedVariant.sellingPlanAllocations).find(
        (allocation) => {
          var _a2;
          return ((_a2 = allocation == null ? void 0 : allocation.sellingPlan) == null ? void 0 : _a2.id) === selectedSellingPlan.id;
        }
      );
    }, [selectedVariant, selectedSellingPlan]);
    const value = React.useMemo(
      () => ({
        product,
        variants,
        variantsConnection: product.variants,
        options,
        selectedVariant,
        setSelectedVariant,
        selectedOptions,
        setSelectedOption,
        setSelectedOptions,
        isOptionInStock,
        selectedSellingPlan,
        setSelectedSellingPlan,
        selectedSellingPlanAllocation,
        sellingPlanGroups,
        sellingPlanGroupsConnection: product.sellingPlanGroups
      }),
      [
        product,
        isOptionInStock,
        options,
        selectedOptions,
        selectedSellingPlan,
        selectedSellingPlanAllocation,
        selectedVariant,
        sellingPlanGroups,
        setSelectedOption,
        variants
      ]
    );
    return /* @__PURE__ */ React.createElement(ProductOptionsContext.Provider, { value }, children);
  }
  function useProduct() {
    const context = React.useContext(ProductOptionsContext);
    if (!context) {
      throw new Error(`'useProduct' must be a child of <ProductProvider />`);
    }
    return context;
  }
  function getSelectedVariant(variants, choices) {
    var _a, _b;
    if (!variants.length || ((_b = (_a = variants == null ? void 0 : variants[0]) == null ? void 0 : _a.selectedOptions) == null ? void 0 : _b.length) !== Object.keys(choices).length) {
      return;
    }
    return variants == null ? void 0 : variants.find((variant) => {
      return Object.entries(choices).every(([name, value]) => {
        var _a2;
        return (_a2 = variant == null ? void 0 : variant.selectedOptions) == null ? void 0 : _a2.some(
          (option) => (option == null ? void 0 : option.name) === name && (option == null ? void 0 : option.value) === value
        );
      });
    });
  }
  function getOptions(variants) {
    const map = variants.reduce((memo, variant) => {
      var _a;
      if (!variant.selectedOptions) {
        throw new Error(`'getOptions' requires 'variant.selectedOptions'`);
      }
      (_a = variant == null ? void 0 : variant.selectedOptions) == null ? void 0 : _a.forEach((opt) => {
        memo[(opt == null ? void 0 : opt.name) ?? ""] = memo[(opt == null ? void 0 : opt.name) ?? ""] || /* @__PURE__ */ new Set();
        memo[(opt == null ? void 0 : opt.name) ?? ""].add((opt == null ? void 0 : opt.value) ?? "");
      });
      return memo;
    }, {});
    return Object.keys(map).map((option) => {
      return {
        name: option,
        values: Array.from(map[option])
      };
    });
  }
  function getVariantBasedOnIdProp(explicitVariantId, variants) {
    if (explicitVariantId) {
      const foundVariant = variants.find(
        (variant) => (variant == null ? void 0 : variant.id) === explicitVariantId
      );
      if (!foundVariant) {
        console.warn(
          `<ProductProvider/> received a 'initialVariantId' prop, but could not actually find a variant with that ID`
        );
      }
      return foundVariant;
    }
    if (explicitVariantId === null) {
      return null;
    }
    if (explicitVariantId === void 0) {
      return variants.find((variant) => variant == null ? void 0 : variant.availableForSale) || variants[0];
    }
  }
  function getSelectedOptions(selectedVariant) {
    return (selectedVariant == null ? void 0 : selectedVariant.selectedOptions) ? selectedVariant.selectedOptions.reduce(
      (memo, optionSet) => {
        memo[(optionSet == null ? void 0 : optionSet.name) ?? ""] = (optionSet == null ? void 0 : optionSet.value) ?? "";
        return memo;
      },
      {}
    ) : {};
  }
  function isProductVariantArray(maybeVariantArray) {
    if (!maybeVariantArray || !Array.isArray(maybeVariantArray)) {
      return false;
    }
    return true;
  }
  function BaseButton(props) {
    const {
      as,
      onClick,
      defaultOnClick,
      children,
      buttonRef,
      ...passthroughProps
    } = props;
    const handleOnClick = React.useCallback(
      (event) => {
        if (onClick) {
          const clickShouldContinue = onClick(event);
          if (typeof clickShouldContinue === "boolean" && clickShouldContinue === false || (event == null ? void 0 : event.defaultPrevented))
            return;
        }
        defaultOnClick == null ? void 0 : defaultOnClick(event);
      },
      [defaultOnClick, onClick]
    );
    const Component = as || "button";
    return /* @__PURE__ */ React.createElement(Component, { ref: buttonRef, onClick: handleOnClick, ...passthroughProps }, children);
  }
  function AddToCartButton(props) {
    const [addingItem, setAddingItem] = React.useState(false);
    const {
      variantId: explicitVariantId,
      quantity = 1,
      attributes,
      sellingPlanId,
      onClick,
      children,
      accessibleAddingToCartLabel,
      ...passthroughProps
    } = props;
    const { status, linesAdd } = useCart();
    const { selectedVariant } = useProduct();
    const variantId = explicitVariantId ?? (selectedVariant == null ? void 0 : selectedVariant.id) ?? "";
    const disabled = explicitVariantId === null || variantId === "" || selectedVariant === null || addingItem || passthroughProps.disabled;
    React.useEffect(() => {
      if (addingItem && status === "idle") {
        setAddingItem(false);
      }
    }, [status, addingItem]);
    const handleAddItem = React.useCallback(() => {
      setAddingItem(true);
      linesAdd([
        {
          quantity,
          merchandiseId: variantId || "",
          attributes,
          sellingPlanId
        }
      ]);
    }, [linesAdd, quantity, variantId, attributes, sellingPlanId]);
    return /* @__PURE__ */ React__namespace.createElement(React__namespace.Fragment, null, /* @__PURE__ */ React__namespace.createElement(
      BaseButton,
      {
        ...passthroughProps,
        disabled,
        onClick,
        defaultOnClick: handleAddItem
      },
      children
    ), accessibleAddingToCartLabel ? /* @__PURE__ */ React__namespace.createElement(
      "p",
      {
        style: {
          position: "absolute",
          width: "1px",
          height: "1px",
          padding: "0",
          margin: "-1px",
          overflow: "hidden",
          clip: "rect(0, 0, 0, 0)",
          whiteSpace: "nowrap",
          borderWidth: "0"
        },
        role: "alert",
        "aria-live": "assertive"
      },
      addingItem ? accessibleAddingToCartLabel : null
    ) : null);
  }
  const AnalyticsEventName = {
    PAGE_VIEW: "PAGE_VIEW",
    ADD_TO_CART: "ADD_TO_CART"
  };
  const AnalyticsPageType = {
    article: "article",
    blog: "blog",
    captcha: "captcha",
    cart: "cart",
    collection: "collection",
    customersAccount: "customers/account",
    customersActivateAccount: "customers/activate_account",
    customersAddresses: "customers/addresses",
    customersLogin: "customers/login",
    customersOrder: "customers/order",
    customersRegister: "customers/register",
    customersResetPassword: "customers/reset_password",
    giftCard: "gift_card",
    home: "index",
    listCollections: "list-collections",
    forbidden: "403",
    notFound: "404",
    page: "page",
    password: "password",
    product: "product",
    policy: "policy",
    search: "search"
  };
  const ShopifySalesChannel = {
    hydrogen: "hydrogen",
    headless: "headless"
  };
  const ShopifyAppId = {
    hydrogen: "6167201",
    headless: "12875497473"
  };
  function schemaWrapper(schemaId, payload) {
    return {
      schema_id: schemaId,
      payload,
      metadata: {
        event_created_at_ms: Date.now()
      }
    };
  }
  function parseGid(gid) {
    const defaultReturn = { id: "", resource: null };
    if (typeof gid !== "string") {
      return defaultReturn;
    }
    const matches = gid.match(/^gid:\/\/shopify\/(\w+)\/([^/]+)/);
    if (!matches || matches.length === 1) {
      return defaultReturn;
    }
    const id = matches[2] ?? null;
    const resource = matches[1] ?? null;
    return { id, resource };
  }
  function addDataIf(keyValuePairs, formattedData) {
    if (typeof keyValuePairs !== "object") {
      return {};
    }
    Object.entries(keyValuePairs).forEach(([key, value]) => {
      if (value) {
        formattedData[key] = value;
      }
    });
    return formattedData;
  }
  function errorIfServer(fnName) {
    if (typeof document === "undefined") {
      console.error(
        `${fnName} should only be used within the useEffect callback or event handlers`
      );
      return true;
    }
    return false;
  }
  const SCHEMA_ID$1 = "trekkie_storefront_page_view/1.4";
  const OXYGEN_DOMAIN = "myshopify.dev";
  function pageView$1(payload) {
    const pageViewPayload = payload;
    const { id, resource } = parseGid(pageViewPayload.resourceId);
    const resourceType = resource ? resource.toLowerCase() : void 0;
    return [
      schemaWrapper(
        SCHEMA_ID$1,
        addDataIf(
          {
            pageType: pageViewPayload.pageType,
            customerId: pageViewPayload.customerId,
            resourceType,
            resourceId: parseInt(id)
          },
          formatPayload$1(pageViewPayload)
        )
      )
    ];
  }
  function formatPayload$1(payload) {
    return {
      appClientId: payload.shopifySalesChannel ? ShopifyAppId[payload.shopifySalesChannel] : ShopifyAppId.headless,
      isMerchantRequest: isMerchantRequest(payload.url),
      hydrogenSubchannelId: payload.storefrontId || "0",
      isPersistentCookie: payload.hasUserConsent,
      uniqToken: payload.uniqueToken,
      visitToken: payload.visitToken,
      microSessionId: buildUUID(),
      microSessionCount: 1,
      url: payload.url,
      path: payload.path,
      search: payload.search,
      referrer: payload.referrer,
      title: payload.title,
      shopId: parseInt(parseGid(payload.shopId).id),
      currency: payload.currency,
      contentLanguage: payload.acceptedLanguage || "en"
    };
  }
  function isMerchantRequest(url) {
    if (typeof url !== "string") {
      return false;
    }
    const hostname = new URL(url).hostname;
    if (hostname.indexOf(OXYGEN_DOMAIN) !== -1 || hostname === "localhost") {
      return true;
    }
    return false;
  }
  const SCHEMA_ID = "custom_storefront_customer_tracking/1.0";
  const PAGE_RENDERED_EVENT_NAME = "page_rendered";
  const COLLECTION_PAGE_RENDERED_EVENT_NAME = "collection_page_rendered";
  const PRODUCT_PAGE_RENDERED_EVENT_NAME = "product_page_rendered";
  const PRODUCT_ADDED_TO_CART_EVENT_NAME = "product_added_to_cart";
  const SEARCH_SUBMITTED_EVENT_NAME = "search_submitted";
  function pageView(payload) {
    const pageViewPayload = payload;
    const additionalPayload = {
      canonical_url: pageViewPayload.canonicalUrl || pageViewPayload.url,
      customer_id: pageViewPayload.customerId
    };
    const pageType = pageViewPayload.pageType;
    const pageViewEvents = [];
    pageViewEvents.push(
      schemaWrapper(
        SCHEMA_ID,
        addDataIf(
          {
            event_name: PAGE_RENDERED_EVENT_NAME,
            ...additionalPayload
          },
          formatPayload(pageViewPayload)
        )
      )
    );
    switch (pageType) {
      case AnalyticsPageType.collection:
        pageViewEvents.push(
          schemaWrapper(
            SCHEMA_ID,
            addDataIf(
              {
                event_name: COLLECTION_PAGE_RENDERED_EVENT_NAME,
                ...additionalPayload,
                collection_name: pageViewPayload.collectionHandle
              },
              formatPayload(pageViewPayload)
            )
          )
        );
        break;
      case AnalyticsPageType.product:
        pageViewEvents.push(
          schemaWrapper(
            SCHEMA_ID,
            addDataIf(
              {
                event_name: PRODUCT_PAGE_RENDERED_EVENT_NAME,
                ...additionalPayload,
                products: formatProductPayload(pageViewPayload.products),
                total_value: pageViewPayload.totalValue
              },
              formatPayload(pageViewPayload)
            )
          )
        );
        break;
      case AnalyticsPageType.search:
        pageViewEvents.push(
          schemaWrapper(
            SCHEMA_ID,
            addDataIf(
              {
                event_name: SEARCH_SUBMITTED_EVENT_NAME,
                ...additionalPayload,
                search_string: pageViewPayload.searchString
              },
              formatPayload(pageViewPayload)
            )
          )
        );
        break;
    }
    return pageViewEvents;
  }
  function addToCart(payload) {
    const addToCartPayload = payload;
    const cartToken = parseGid(addToCartPayload.cartId);
    const cart_token = (cartToken == null ? void 0 : cartToken.id) ? `${cartToken.id}` : null;
    return [
      schemaWrapper(
        SCHEMA_ID,
        addDataIf(
          {
            event_name: PRODUCT_ADDED_TO_CART_EVENT_NAME,
            customerId: addToCartPayload.customerId,
            cart_token,
            total_value: addToCartPayload.totalValue,
            products: formatProductPayload(addToCartPayload.products)
          },
          formatPayload(addToCartPayload)
        )
      )
    ];
  }
  function formatPayload(payload) {
    return {
      source: payload.shopifySalesChannel || ShopifySalesChannel.headless,
      hydrogenSubchannelId: payload.storefrontId || "0",
      is_persistent_cookie: payload.hasUserConsent,
      ccpa_enforced: false,
      gdpr_enforced: false,
      unique_token: payload.uniqueToken,
      event_time: Date.now(),
      event_id: buildUUID(),
      event_source_url: payload.url,
      referrer: payload.referrer,
      user_agent: payload.userAgent,
      navigation_type: payload.navigationType,
      navigation_api: payload.navigationApi,
      shop_id: parseInt(parseGid(payload.shopId).id),
      currency: payload.currency
    };
  }
  function formatProductPayload(products) {
    return products ? products.map((p) => {
      const product = addDataIf(
        {
          variant_gid: p.variantGid,
          category: p.category,
          sku: p.sku,
          product_id: parseInt(parseGid(p.productGid).id),
          variant_id: parseInt(parseGid(p.variantGid).id)
        },
        {
          product_gid: p.productGid,
          name: p.name,
          variant: p.variantName || "",
          brand: p.brand,
          price: p.price,
          quantity: Number(p.quantity || 0)
        }
      );
      return JSON.stringify(product);
    }) : [];
  }
  function sendShopifyAnalytics(event, shopDomain) {
    const { eventName, payload } = event;
    if (!payload.hasUserConsent)
      return Promise.resolve();
    let events = [];
    if (eventName === AnalyticsEventName.PAGE_VIEW) {
      const pageViewPayload = payload;
      events = events.concat(
        pageView$1(pageViewPayload),
        pageView(pageViewPayload)
      );
    } else if (eventName === AnalyticsEventName.ADD_TO_CART) {
      events = events.concat(
        addToCart(payload)
      );
    }
    if (events.length) {
      return sendToShopify(events, shopDomain);
    } else {
      return Promise.resolve();
    }
  }
  const ERROR_MESSAGE = "sendShopifyAnalytics request is unsuccessful";
  function sendToShopify(events, shopDomain) {
    const eventsToBeSent = {
      events,
      metadata: {
        event_sent_at_ms: Date.now()
      }
    };
    try {
      return fetch(
        shopDomain ? `https://${shopDomain}/.well-known/shopify/monorail/unstable/produce_batch` : "https://monorail-edge.shopifysvc.com/unstable/produce_batch",
        {
          method: "post",
          headers: {
            "content-type": "text/plain"
          },
          body: JSON.stringify(eventsToBeSent)
        }
      ).then((response) => {
        if (!response.ok) {
          throw new Error("Response failed");
        }
        return response.text();
      }).then((data) => {
        if (data) {
          const jsonResponse = JSON.parse(data);
          jsonResponse.result.forEach((eventResponse) => {
            if (eventResponse.status !== 200) {
              console.error(ERROR_MESSAGE, "\n\n", eventResponse.message);
            }
          });
        }
      }).catch((err) => {
        console.error(ERROR_MESSAGE, err);
        if (true) {
          throw new Error(ERROR_MESSAGE);
        }
      });
    } catch (error) {
      return Promise.resolve();
    }
  }
  function getClientBrowserParameters() {
    if (errorIfServer("getClientBrowserParameters")) {
      return {
        uniqueToken: "",
        visitToken: "",
        url: "",
        path: "",
        search: "",
        referrer: "",
        title: "",
        userAgent: "",
        navigationType: "",
        navigationApi: ""
      };
    }
    const [navigationType, navigationApi] = getNavigationType();
    const cookies = getShopifyCookies(document.cookie);
    return {
      uniqueToken: cookies[SHOPIFY_Y],
      visitToken: cookies[SHOPIFY_S],
      url: location.href,
      path: location.pathname,
      search: location.search,
      referrer: document.referrer,
      title: document.title,
      userAgent: navigator.userAgent,
      navigationType,
      navigationApi
    };
  }
  function getNavigationTypeExperimental() {
    try {
      const navigationEntries = (performance == null ? void 0 : performance.getEntriesByType) && (performance == null ? void 0 : performance.getEntriesByType("navigation"));
      if (navigationEntries && navigationEntries[0]) {
        const rawType = window.performance.getEntriesByType(
          "navigation"
        )[0]["type"];
        const navType = rawType && rawType.toString();
        return navType;
      }
    } catch (err) {
    }
    return void 0;
  }
  function getNavigationTypeLegacy() {
    var _a, _b;
    try {
      if (PerformanceNavigation && ((_a = performance == null ? void 0 : performance.navigation) == null ? void 0 : _a.type) !== null && ((_b = performance == null ? void 0 : performance.navigation) == null ? void 0 : _b.type) !== void 0) {
        const rawType = performance.navigation.type;
        switch (rawType) {
          case PerformanceNavigation.TYPE_NAVIGATE:
            return "navigate";
            break;
          case PerformanceNavigation.TYPE_RELOAD:
            return "reload";
            break;
          case PerformanceNavigation.TYPE_BACK_FORWARD:
            return "back_forward";
            break;
          default:
            return `unknown: ${rawType}`;
        }
      }
    } catch (err) {
    }
    return void 0;
  }
  function getNavigationType() {
    try {
      let navApi = "PerformanceNavigationTiming";
      let navType = getNavigationTypeExperimental();
      if (!navType) {
        navType = getNavigationTypeLegacy();
        navApi = "performance.navigation";
      }
      if (navType) {
        return [navType, navApi];
      } else {
        return ["unknown", "unknown"];
      }
    } catch (err) {
    }
    return ["error", "error"];
  }
  function BuyNowButton(props) {
    const { cartCreate, checkoutUrl } = useCart();
    const [loading, setLoading] = React.useState(false);
    const {
      quantity,
      variantId,
      onClick,
      attributes,
      children,
      ...passthroughProps
    } = props;
    React.useEffect(() => {
      if (loading && checkoutUrl) {
        window.location.href = checkoutUrl;
      }
    }, [loading, checkoutUrl]);
    const handleBuyNow = React.useCallback(() => {
      setLoading(true);
      cartCreate({
        lines: [
          {
            quantity: quantity ?? 1,
            merchandiseId: variantId,
            attributes
          }
        ]
      });
    }, [cartCreate, quantity, variantId, attributes]);
    return /* @__PURE__ */ React.createElement(
      BaseButton,
      {
        disabled: loading ?? passthroughProps.disabled,
        ...passthroughProps,
        onClick,
        defaultOnClick: handleBuyNow
      },
      children
    );
  }
  function CartCheckoutButton(props) {
    const [requestedCheckout, setRequestedCheckout] = React.useState(false);
    const { status, checkoutUrl } = useCart();
    const { children, ...passthroughProps } = props;
    React.useEffect(() => {
      if (requestedCheckout && checkoutUrl && status === "idle") {
        window.location.href = checkoutUrl;
      }
    }, [requestedCheckout, status, checkoutUrl]);
    return /* @__PURE__ */ React.createElement(
      BaseButton,
      {
        ...passthroughProps,
        disabled: requestedCheckout || passthroughProps.disabled,
        onClick: () => setRequestedCheckout(true)
      },
      children
    );
  }
  function useMoney(money) {
    const { countryIsoCode, languageIsoCode } = useShop();
    const locale = `${languageIsoCode}-${countryIsoCode}`;
    if (!locale) {
      throw new Error(
        `useMoney(): Unable to get 'locale' from 'useShop()', which means that 'locale' was not passed to '<ShopifyProvider/>'. 'locale' is required for 'useMoney()' to work`
      );
    }
    const amount = parseFloat(money.amount);
    const options = React.useMemo(
      () => ({
        style: "currency",
        currency: money.currencyCode
      }),
      [money.currencyCode]
    );
    const defaultFormatter = useLazyFormatter(locale, options);
    const nameFormatter = useLazyFormatter(locale, {
      ...options,
      currencyDisplay: "name"
    });
    const narrowSymbolFormatter = useLazyFormatter(locale, {
      ...options,
      currencyDisplay: "narrowSymbol"
    });
    const withoutTrailingZerosFormatter = useLazyFormatter(locale, {
      ...options,
      minimumFractionDigits: 0,
      maximumFractionDigits: 0
    });
    const withoutCurrencyFormatter = useLazyFormatter(locale);
    const withoutTrailingZerosOrCurrencyFormatter = useLazyFormatter(locale, {
      minimumFractionDigits: 0,
      maximumFractionDigits: 0
    });
    const isPartCurrency = (part) => part.type === "currency";
    const lazyFormatters = React.useMemo(
      () => ({
        original: () => money,
        currencyCode: () => money.currencyCode,
        localizedString: () => defaultFormatter().format(amount),
        parts: () => defaultFormatter().formatToParts(amount),
        withoutTrailingZeros: () => amount % 1 === 0 ? withoutTrailingZerosFormatter().format(amount) : defaultFormatter().format(amount),
        withoutTrailingZerosAndCurrency: () => amount % 1 === 0 ? withoutTrailingZerosOrCurrencyFormatter().format(amount) : withoutCurrencyFormatter().format(amount),
        currencyName: () => {
          var _a;
          return ((_a = nameFormatter().formatToParts(amount).find(isPartCurrency)) == null ? void 0 : _a.value) ?? money.currencyCode;
        },
        // e.g. "US dollars"
        currencySymbol: () => {
          var _a;
          return ((_a = defaultFormatter().formatToParts(amount).find(isPartCurrency)) == null ? void 0 : _a.value) ?? money.currencyCode;
        },
        // e.g. "USD"
        currencyNarrowSymbol: () => {
          var _a;
          return ((_a = narrowSymbolFormatter().formatToParts(amount).find(isPartCurrency)) == null ? void 0 : _a.value) ?? "";
        },
        // e.g. "$"
        amount: () => defaultFormatter().formatToParts(amount).filter(
          (part) => ["decimal", "fraction", "group", "integer", "literal"].includes(
            part.type
          )
        ).map((part) => part.value).join("")
      }),
      [
        money,
        amount,
        nameFormatter,
        defaultFormatter,
        narrowSymbolFormatter,
        withoutCurrencyFormatter,
        withoutTrailingZerosFormatter,
        withoutTrailingZerosOrCurrencyFormatter
      ]
    );
    return React.useMemo(
      () => new Proxy(lazyFormatters, {
        // eslint-disable-next-line @typescript-eslint/no-unsafe-return, @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-unsafe-call
        get: (target, key) => {
          var _a;
          return (_a = Reflect.get(target, key)) == null ? void 0 : _a.call(null);
        }
      }),
      [lazyFormatters]
    );
  }
  function useLazyFormatter(locale, options) {
    return React.useMemo(() => {
      let memoized;
      return () => memoized ?? (memoized = new Intl.NumberFormat(locale, options));
    }, [locale, options]);
  }
  function Money({
    data,
    as,
    withoutCurrency,
    withoutTrailingZeros,
    measurement,
    measurementSeparator = "/",
    ...passthroughProps
  }) {
    if (!isMoney(data)) {
      throw new Error(
        `<Money/> needs a valid 'data' prop that has 'amount' and 'currencyCode'`
      );
    }
    const moneyObject = useMoney(data);
    const Wrapper = as ?? "div";
    let output = moneyObject.localizedString;
    if (withoutCurrency || withoutTrailingZeros) {
      if (withoutCurrency && !withoutTrailingZeros) {
        output = moneyObject.amount;
      } else if (!withoutCurrency && withoutTrailingZeros) {
        output = moneyObject.withoutTrailingZeros;
      } else {
        output = moneyObject.withoutTrailingZerosAndCurrency;
      }
    }
    return /* @__PURE__ */ React.createElement(Wrapper, { ...passthroughProps }, output, measurement && measurement.referenceUnit && /* @__PURE__ */ React.createElement(React.Fragment, null, measurementSeparator, measurement.referenceUnit));
  }
  function isMoney(maybeMoney) {
    return typeof maybeMoney.amount === "string" && !!maybeMoney.amount && typeof maybeMoney.currencyCode === "string" && !!maybeMoney.currencyCode;
  }
  function CartCost(props) {
    const { cost } = useCart();
    const { amountType = "total", children, ...passthroughProps } = props;
    let amount;
    if (amountType == "total") {
      amount = cost == null ? void 0 : cost.totalAmount;
    } else if (amountType == "subtotal") {
      amount = cost == null ? void 0 : cost.subtotalAmount;
    } else if (amountType == "tax") {
      amount = cost == null ? void 0 : cost.totalTaxAmount;
    } else if (amountType == "duty") {
      amount = cost == null ? void 0 : cost.totalDutyAmount;
    }
    if (amount == null) {
      return null;
    }
    return /* @__PURE__ */ React.createElement(Money, { ...passthroughProps, data: amount }, children);
  }
  const CartLineContext = React.createContext(null);
  function useCartLine() {
    const context = React.useContext(CartLineContext);
    if (context == null) {
      throw new Error("Expected a cart line context but none was found");
    }
    return context;
  }
  function CartLineProvider({
    children,
    line
  }) {
    return /* @__PURE__ */ React.createElement(CartLineContext.Provider, { value: line }, children);
  }
  function CartLineQuantity(props) {
    const cartLine = useCartLine();
    const { as, ...passthroughProps } = props;
    const Wrapper = as ? as : "span";
    return /* @__PURE__ */ React.createElement(Wrapper, { ...passthroughProps }, cartLine.quantity);
  }
  function CartLineQuantityAdjustButton(props) {
    const { status, linesRemove, linesUpdate } = useCart();
    const cartLine = useCartLine();
    const { children, adjust, onClick, ...passthroughProps } = props;
    const handleAdjust = React.useCallback(() => {
      if (adjust === "remove") {
        linesRemove([(cartLine == null ? void 0 : cartLine.id) ?? ""]);
        return;
      }
      const quantity = adjust === "decrease" ? ((cartLine == null ? void 0 : cartLine.quantity) ?? 0) - 1 : ((cartLine == null ? void 0 : cartLine.quantity) ?? 0) + 1;
      if (quantity <= 0) {
        linesRemove([(cartLine == null ? void 0 : cartLine.id) ?? ""]);
        return;
      }
      const lineUpdate = {
        id: (cartLine == null ? void 0 : cartLine.id) ?? "",
        quantity,
        attributes: (cartLine == null ? void 0 : cartLine.attributes) ?? []
      };
      linesUpdate([lineUpdate]);
    }, [
      adjust,
      cartLine == null ? void 0 : cartLine.attributes,
      cartLine == null ? void 0 : cartLine.id,
      cartLine == null ? void 0 : cartLine.quantity,
      linesRemove,
      linesUpdate
    ]);
    return /* @__PURE__ */ React.createElement(
      BaseButton,
      {
        ...passthroughProps,
        onClick,
        defaultOnClick: handleAdjust,
        disabled: typeof passthroughProps.disabled !== "undefined" ? passthroughProps.disabled : status !== "idle"
      },
      children
    );
  }
  const storefrontApiCustomScalars = {
    // Keep in sync with the definitions in the app/nextjs/codegen.ts!
    DateTime: "string",
    Decimal: "string",
    HTML: "string",
    URL: "string",
    Color: "string",
    UnsignedInt64: "string"
  };
  function ExternalVideo(props) {
    const {
      data,
      options,
      id = data.id,
      frameBorder = "0",
      allow = "accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture",
      allowFullScreen = true,
      loading = "lazy",
      ...passthroughProps
    } = props;
    if (!data.embedUrl) {
      throw new Error(`<ExternalVideo/> requires the 'embedUrl' property`);
    }
    let finalUrl = data.embedUrl;
    if (options) {
      const urlObject = new URL(data.embedUrl);
      for (const key of Object.keys(options)) {
        urlObject.searchParams.set(key, options[key]);
      }
      finalUrl = urlObject.toString();
    }
    return /* @__PURE__ */ React.createElement(
      "iframe",
      {
        ...passthroughProps,
        id: id ?? data.embedUrl,
        title: data.alt ?? data.id ?? "external video",
        frameBorder,
        allow,
        allowFullScreen,
        src: finalUrl,
        loading
      }
    );
  }
  const IMAGE_FRAGMENT = `#graphql
  fragment Image on Image {
    altText
    url
    width
    height
  }
`;
  const Image = React__namespace.forwardRef(
    ({
      alt,
      aspectRatio,
      crop = "center",
      data,
      decoding = "async",
      height = "auto",
      loader = shopifyLoader,
      loaderOptions,
      loading = "lazy",
      sizes,
      src,
      srcSetOptions = {
        intervals: 15,
        startingWidth: 200,
        incrementSize: 200,
        placeholderWidth: 100
      },
      width = "100%",
      widths,
      ...passthroughProps
    }, ref) => {
      {
        if (loaderOptions) {
          console.warn(
            [
              `Deprecated property from original Image component in use:`,
              `Use the \`crop\`, \`width\`, \`height\`, and src props, or`,
              `the \`data\` prop to achieve the same result. Image used is ${src || (data == null ? void 0 : data.url) || (passthroughProps == null ? void 0 : passthroughProps.key) || "unknown"}`
            ].join(" ")
          );
        }
        if (widths) {
          console.warn(
            [
              `Deprecated property from original Image component in use:`,
              `\`widths\` are now calculated automatically based on the`,
              `config and width props. Image used is ${src || (data == null ? void 0 : data.url) || (passthroughProps == null ? void 0 : passthroughProps.key) || "unknown"}`
            ].join(" ")
          );
        }
      }
      const normalizedData = React__namespace.useMemo(() => {
        const dataWidth = (data == null ? void 0 : data.width) && (data == null ? void 0 : data.height) ? data == null ? void 0 : data.width : void 0;
        const dataHeight = (data == null ? void 0 : data.width) && (data == null ? void 0 : data.height) ? data == null ? void 0 : data.height : void 0;
        return {
          width: dataWidth,
          height: dataHeight,
          unitsMatch: Boolean(unitsMatch(dataWidth, dataHeight))
        };
      }, [data]);
      const normalizedProps = React__namespace.useMemo(() => {
        const nWidthProp = width || "100%";
        const widthParts = getUnitValueParts(nWidthProp.toString());
        const nWidth = `${widthParts.number}${widthParts.unit}`;
        const autoHeight = height === void 0 || height === null;
        const heightParts = autoHeight ? null : getUnitValueParts(height.toString());
        const fixedHeight = heightParts ? `${heightParts.number}${heightParts.unit}` : "";
        const nHeight = autoHeight ? "auto" : fixedHeight;
        const nSrc = src || (data == null ? void 0 : data.url);
        if (!nSrc) {
          console.warn(
            `No src or data.url provided to Image component.`,
            (passthroughProps == null ? void 0 : passthroughProps.key) || ""
          );
        }
        const nAlt = (data == null ? void 0 : data.altText) && !alt ? data == null ? void 0 : data.altText : alt || "";
        const nAspectRatio = aspectRatio ? aspectRatio : normalizedData.unitsMatch ? [
          getNormalizedFixedUnit(normalizedData.width),
          getNormalizedFixedUnit(normalizedData.height)
        ].join("/") : void 0;
        return {
          width: nWidth,
          height: nHeight,
          src: nSrc,
          alt: nAlt,
          aspectRatio: nAspectRatio
        };
      }, [
        width,
        height,
        src,
        data,
        alt,
        aspectRatio,
        normalizedData,
        passthroughProps == null ? void 0 : passthroughProps.key
      ]);
      const { intervals, startingWidth, incrementSize, placeholderWidth } = srcSetOptions;
      const imageWidths = React__namespace.useMemo(() => {
        return generateImageWidths(
          width,
          intervals,
          startingWidth,
          incrementSize
        );
      }, [width, intervals, startingWidth, incrementSize]);
      const fixedWidth = isFixedWidth(normalizedProps.width);
      if (!sizes && !fixedWidth) {
        console.warn(
          [
            "No sizes prop provided to Image component,",
            "you may be loading unnecessarily large images.",
            `Image used is ${src || (data == null ? void 0 : data.url) || (passthroughProps == null ? void 0 : passthroughProps.key) || "unknown"}`
          ].join(" ")
        );
      }
      if (fixedWidth) {
        return /* @__PURE__ */ React__namespace.createElement(
          FixedWidthImage,
          {
            aspectRatio,
            crop,
            decoding,
            height,
            imageWidths,
            loader,
            loading,
            normalizedProps,
            passthroughProps,
            ref,
            width
          }
        );
      } else {
        return /* @__PURE__ */ React__namespace.createElement(
          FluidImage,
          {
            aspectRatio,
            crop,
            decoding,
            imageWidths,
            loader,
            loading,
            normalizedProps,
            passthroughProps,
            placeholderWidth,
            ref,
            sizes
          }
        );
      }
    }
  );
  function FixedWidthImage({
    aspectRatio,
    crop,
    decoding,
    height,
    imageWidths,
    loader = shopifyLoader,
    loading,
    normalizedProps,
    passthroughProps,
    ref,
    width
  }) {
    const fixed = React__namespace.useMemo(() => {
      const intWidth = getNormalizedFixedUnit(width);
      const intHeight = getNormalizedFixedUnit(height);
      const fixedAspectRatio = aspectRatio ? aspectRatio : unitsMatch(normalizedProps.width, normalizedProps.height) ? [intWidth, intHeight].join("/") : normalizedProps.aspectRatio ? normalizedProps.aspectRatio : void 0;
      const sizesArray = imageWidths === void 0 ? void 0 : generateSizes(imageWidths, fixedAspectRatio, crop);
      const fixedHeight = intHeight ? intHeight : fixedAspectRatio && intWidth ? intWidth * (parseAspectRatio(fixedAspectRatio) ?? 1) : void 0;
      const srcSet = generateSrcSet(normalizedProps.src, sizesArray, loader);
      const src = loader({
        src: normalizedProps.src,
        width: intWidth,
        height: fixedHeight,
        crop: normalizedProps.height === "auto" ? void 0 : crop
      });
      return {
        width: intWidth,
        aspectRatio: fixedAspectRatio,
        height: fixedHeight,
        srcSet,
        src
      };
    }, [aspectRatio, crop, height, imageWidths, loader, normalizedProps, width]);
    return /* @__PURE__ */ React__namespace.createElement(
      "img",
      {
        ref,
        alt: normalizedProps.alt,
        decoding,
        height: fixed.height,
        loading,
        src: fixed.src,
        srcSet: fixed.srcSet,
        width: fixed.width,
        style: {
          aspectRatio: fixed.aspectRatio,
          ...passthroughProps.style
        },
        ...passthroughProps
      }
    );
  }
  function FluidImage({
    crop,
    decoding,
    imageWidths,
    loader = shopifyLoader,
    loading,
    normalizedProps,
    passthroughProps,
    placeholderWidth,
    ref,
    sizes
  }) {
    const fluid = React__namespace.useMemo(() => {
      const sizesArray = imageWidths === void 0 ? void 0 : generateSizes(imageWidths, normalizedProps.aspectRatio, crop);
      const placeholderHeight = normalizedProps.aspectRatio && placeholderWidth ? placeholderWidth * (parseAspectRatio(normalizedProps.aspectRatio) ?? 1) : void 0;
      const srcSet = generateSrcSet(normalizedProps.src, sizesArray, loader);
      const src = loader({
        src: normalizedProps.src,
        width: placeholderWidth,
        height: placeholderHeight,
        crop
      });
      return {
        placeholderHeight,
        srcSet,
        src
      };
    }, [crop, imageWidths, loader, normalizedProps, placeholderWidth]);
    return /* @__PURE__ */ React__namespace.createElement(
      "img",
      {
        ref,
        alt: normalizedProps.alt,
        decoding,
        height: fluid.placeholderHeight,
        loading,
        sizes,
        src: fluid.src,
        srcSet: fluid.srcSet,
        width: placeholderWidth,
        ...passthroughProps,
        style: {
          width: normalizedProps.width,
          aspectRatio: normalizedProps.aspectRatio,
          ...passthroughProps.style
        }
      }
    );
  }
  function shopifyLoader({ src, width, height, crop }) {
    if (!src) {
      return "";
    }
    const url = new URL(src);
    if (width) {
      url.searchParams.append("width", Math.round(width).toString());
    }
    if (height) {
      url.searchParams.append("height", Math.round(height).toString());
    }
    if (crop) {
      url.searchParams.append("crop", crop);
    }
    return url.href;
  }
  function unitsMatch(width = "100%", height = "auto") {
    return getUnitValueParts(width.toString()).unit === getUnitValueParts(height.toString()).unit;
  }
  function getUnitValueParts(value) {
    const unit = value.replace(/[0-9.]/g, "");
    const number = parseFloat(value.replace(unit, ""));
    return {
      unit: unit === "" ? number === void 0 ? "auto" : "px" : unit,
      number
    };
  }
  function getNormalizedFixedUnit(value) {
    if (value === void 0) {
      return;
    }
    const { unit, number } = getUnitValueParts(value.toString());
    switch (unit) {
      case "em":
        return number * 16;
      case "rem":
        return number * 16;
      case "px":
        return number;
      case "":
        return number;
      default:
        return;
    }
  }
  function isFixedWidth(width) {
    const fixedEndings = /\d(px|em|rem)$/;
    return typeof width === "number" || typeof width === "string" && fixedEndings.test(width);
  }
  function generateSrcSet(src, sizesArray, loader = shopifyLoader) {
    if (!src) {
      return "";
    }
    if ((sizesArray == null ? void 0 : sizesArray.length) === 0 || !sizesArray) {
      return src;
    }
    return sizesArray.map(
      (size, i2) => `${loader({
        src,
        width: size.width,
        height: size.height,
        crop: size.crop
      })} ${sizesArray.length === 3 ? `${i2 + 1}x` : `${size.width ?? 0}w`}`
    ).join(`, `);
  }
  function generateImageWidths(width = "100%", intervals, startingWidth, incrementSize) {
    const responsive = Array.from(
      { length: intervals },
      (_, i2) => i2 * incrementSize + startingWidth
    );
    const fixed = Array.from(
      { length: 3 },
      (_, i2) => (i2 + 1) * (getNormalizedFixedUnit(width) ?? 0)
    );
    return isFixedWidth(width) ? fixed : responsive;
  }
  function parseAspectRatio(aspectRatio) {
    if (!aspectRatio)
      return;
    const [width, height] = aspectRatio.split("/");
    return 1 / (Number(width) / Number(height));
  }
  function generateSizes(imageWidths, aspectRatio, crop = "center") {
    if (!imageWidths)
      return;
    const sizes = imageWidths.map((width) => {
      return {
        width,
        height: aspectRatio ? width * (parseAspectRatio(aspectRatio) ?? 1) : void 0,
        crop
      };
    });
    return sizes;
  }
  function Video(props) {
    var _a;
    const {
      data,
      previewImageOptions,
      id = data.id,
      playsInline = true,
      controls = true,
      sourceProps = {},
      ...passthroughProps
    } = props;
    const posterUrl = shopifyLoader({
      src: ((_a = data.previewImage) == null ? void 0 : _a.url) ?? "",
      ...previewImageOptions
    });
    if (!data.sources) {
      throw new Error(`<Video/> requires a 'data.sources' array`);
    }
    return (
      // eslint-disable-next-line jsx-a11y/media-has-caption
      /* @__PURE__ */ React.createElement(
        "video",
        {
          ...passthroughProps,
          id,
          playsInline,
          controls,
          poster: posterUrl
        },
        data.sources.map((source) => {
          if (!((source == null ? void 0 : source.url) && (source == null ? void 0 : source.mimeType))) {
            throw new Error(`<Video/> needs 'source.url' and 'source.mimeType'`);
          }
          return /* @__PURE__ */ React.createElement(
            "source",
            {
              ...sourceProps,
              key: source.url,
              src: source.url,
              type: source.mimeType
            }
          );
        })
      )
    );
  }
  const SCRIPTS_LOADED = {};
  function loadScript(src, options) {
    const isScriptLoaded = SCRIPTS_LOADED[src];
    if (isScriptLoaded) {
      return isScriptLoaded;
    }
    const promise = new Promise((resolve, reject) => {
      const script = document.createElement("script");
      if (options == null ? void 0 : options.module) {
        script.type = "module";
      } else {
        script.type = "text/javascript";
      }
      script.src = src;
      script.onload = () => {
        resolve(true);
      };
      script.onerror = () => {
        reject(false);
      };
      if ((options == null ? void 0 : options.in) === "head") {
        document.head.appendChild(script);
      } else {
        document.body.appendChild(script);
      }
    });
    SCRIPTS_LOADED[src] = promise;
    return promise;
  }
  function useLoadScript(url, options) {
    const [status, setStatus] = React.useState("loading");
    const stringifiedOptions = JSON.stringify(options);
    React.useEffect(() => {
      async function loadScriptWrapper() {
        try {
          setStatus("loading");
          await loadScript(url, options);
          setStatus("done");
        } catch (error) {
          setStatus("error");
        }
      }
      loadScriptWrapper().catch(() => {
        setStatus("error");
      });
    }, [url, stringifiedOptions, options]);
    return status;
  }
  function ModelViewer(props) {
    var _a, _b, _c;
    const [modelViewer, setModelViewer] = React.useState(
      void 0
    );
    const callbackRef = React.useCallback((node) => {
      setModelViewer(node);
    }, []);
    const { data, children, className, ...passthroughProps } = props;
    const modelViewerLoadedStatus = useLoadScript(
      "https://unpkg.com/@google/model-viewer@v1.12.1/dist/model-viewer.min.js",
      {
        module: true
      }
    );
    React.useEffect(() => {
      if (!modelViewer) {
        return;
      }
      if (passthroughProps.onError)
        modelViewer.addEventListener("error", passthroughProps.onError);
      if (passthroughProps.onLoad)
        modelViewer.addEventListener("load", passthroughProps.onLoad);
      if (passthroughProps.onPreload)
        modelViewer.addEventListener("preload", passthroughProps.onPreload);
      if (passthroughProps.onModelVisibility)
        modelViewer.addEventListener(
          "model-visibility",
          passthroughProps.onModelVisibility
        );
      if (passthroughProps.onProgress)
        modelViewer.addEventListener("progress", passthroughProps.onProgress);
      if (passthroughProps.onArStatus)
        modelViewer.addEventListener("ar-status", passthroughProps.onArStatus);
      if (passthroughProps.onArTracking)
        modelViewer.addEventListener(
          "ar-tracking",
          passthroughProps.onArTracking
        );
      if (passthroughProps.onQuickLookButtonTapped)
        modelViewer.addEventListener(
          "quick-look-button-tapped",
          passthroughProps.onQuickLookButtonTapped
        );
      if (passthroughProps.onCameraChange)
        modelViewer.addEventListener(
          "camera-change",
          passthroughProps.onCameraChange
        );
      if (passthroughProps.onEnvironmentChange)
        modelViewer.addEventListener(
          "environment-change",
          passthroughProps.onEnvironmentChange
        );
      if (passthroughProps.onPlay)
        modelViewer.addEventListener("play", passthroughProps.onPlay);
      if (passthroughProps.onPause)
        modelViewer.addEventListener("ar-status", passthroughProps.onPause);
      if (passthroughProps.onSceneGraphReady)
        modelViewer.addEventListener(
          "scene-graph-ready",
          passthroughProps.onSceneGraphReady
        );
      return () => {
        if (modelViewer == null) {
          return;
        }
        if (passthroughProps.onError)
          modelViewer.removeEventListener("error", passthroughProps.onError);
        if (passthroughProps.onLoad)
          modelViewer.removeEventListener("load", passthroughProps.onLoad);
        if (passthroughProps.onPreload)
          modelViewer.removeEventListener("preload", passthroughProps.onPreload);
        if (passthroughProps.onModelVisibility)
          modelViewer.removeEventListener(
            "model-visibility",
            passthroughProps.onModelVisibility
          );
        if (passthroughProps.onProgress)
          modelViewer.removeEventListener(
            "progress",
            passthroughProps.onProgress
          );
        if (passthroughProps.onArStatus)
          modelViewer.removeEventListener(
            "ar-status",
            passthroughProps.onArStatus
          );
        if (passthroughProps.onArTracking)
          modelViewer.removeEventListener(
            "ar-tracking",
            passthroughProps.onArTracking
          );
        if (passthroughProps.onQuickLookButtonTapped)
          modelViewer.removeEventListener(
            "quick-look-button-tapped",
            passthroughProps.onQuickLookButtonTapped
          );
        if (passthroughProps.onCameraChange)
          modelViewer.removeEventListener(
            "camera-change",
            passthroughProps.onCameraChange
          );
        if (passthroughProps.onEnvironmentChange)
          modelViewer.removeEventListener(
            "environment-change",
            passthroughProps.onEnvironmentChange
          );
        if (passthroughProps.onPlay)
          modelViewer.removeEventListener("play", passthroughProps.onPlay);
        if (passthroughProps.onPause)
          modelViewer.removeEventListener("ar-status", passthroughProps.onPause);
        if (passthroughProps.onSceneGraphReady)
          modelViewer.removeEventListener(
            "scene-graph-ready",
            passthroughProps.onSceneGraphReady
          );
      };
    }, [
      modelViewer,
      passthroughProps.onArStatus,
      passthroughProps.onArTracking,
      passthroughProps.onCameraChange,
      passthroughProps.onEnvironmentChange,
      passthroughProps.onError,
      passthroughProps.onLoad,
      passthroughProps.onModelVisibility,
      passthroughProps.onPause,
      passthroughProps.onPlay,
      passthroughProps.onPreload,
      passthroughProps.onProgress,
      passthroughProps.onQuickLookButtonTapped,
      passthroughProps.onSceneGraphReady
    ]);
    if (modelViewerLoadedStatus !== "done") {
      return null;
    }
    if (!((_b = (_a = data.sources) == null ? void 0 : _a[0]) == null ? void 0 : _b.url)) {
      const sourcesUrlError = `<ModelViewer/> requires 'data.sources' prop to be an array, with an object that has a property 'url' on it. Rendering 'null'`;
      {
        throw new Error(sourcesUrlError);
      }
    }
    if (!data.alt) {
      console.warn(
        `<ModelViewer/> requires the 'data.alt' prop for accessibility`
      );
    }
    return /* @__PURE__ */ React.createElement(
      "model-viewer",
      {
        ref: callbackRef,
        ...passthroughProps,
        className,
        id: passthroughProps.id ?? data.id,
        src: data.sources[0].url,
        alt: data.alt ?? null,
        "camera-controls": passthroughProps.cameraControls ?? true,
        poster: (passthroughProps.poster || ((_c = data.previewImage) == null ? void 0 : _c.url)) ?? null,
        autoplay: passthroughProps.autoplay ?? true,
        loading: passthroughProps.loading,
        reveal: passthroughProps.reveal,
        ar: passthroughProps.ar,
        "ar-modes": passthroughProps.arModes,
        "ar-scale": passthroughProps.arScale,
        "ar-placement": passthroughProps.arPlacement,
        "ios-src": passthroughProps.iosSrc,
        "touch-action": passthroughProps.touchAction,
        "disable-zoom": passthroughProps.disableZoom,
        "orbit-sensitivity": passthroughProps.orbitSensitivity,
        "auto-rotate": passthroughProps.autoRotate,
        "auto-rotate-delay": passthroughProps.autoRotateDelay,
        "rotation-per-second": passthroughProps.rotationPerSecond,
        "interaction-policy": passthroughProps.interactionPolicy,
        "interaction-prompt": passthroughProps.interactionPrompt,
        "interaction-prompt-style": passthroughProps.interactionPromptStyle,
        "interaction-prompt-threshold": passthroughProps.interactionPromptThreshold,
        "camera-orbit": passthroughProps.cameraOrbit,
        "camera-target": passthroughProps.cameraTarget,
        "field-of-view": passthroughProps.fieldOfView,
        "max-camera-orbit": passthroughProps.maxCameraOrbit,
        "min-camera-orbit": passthroughProps.minCameraOrbit,
        "max-field-of-view": passthroughProps.maxFieldOfView,
        "min-field-of-view": passthroughProps.minFieldOfView,
        bounds: passthroughProps.bounds,
        "interpolation-decay": passthroughProps.interpolationDecay ?? 100,
        "skybox-image": passthroughProps.skyboxImage,
        "environment-image": passthroughProps.environmentImage,
        exposure: passthroughProps.exposure,
        "shadow-intensity": passthroughProps.shadowIntensity ?? 0,
        "shadow-softness": passthroughProps.shadowSoftness ?? 0,
        "animation-name": passthroughProps.animationName,
        "animation-crossfade-duration": passthroughProps.animationCrossfadeDuration,
        "variant-name": passthroughProps.variantName,
        orientation: passthroughProps.orientation,
        scale: passthroughProps.scale
      },
      children
    );
  }
  function MediaFile({
    data,
    mediaOptions,
    ...passthroughProps
  }) {
    switch (data.__typename) {
      case "MediaImage": {
        if (!data.image) {
          const noDataImage = `<MediaFile/>: 'data.image' does not exist for __typename of 'MediaImage'; rendering 'null' by default.`;
          {
            throw new Error(noDataImage);
          }
        }
        return /* @__PURE__ */ React.createElement(
          Image,
          {
            ...passthroughProps,
            ...mediaOptions == null ? void 0 : mediaOptions.image,
            data: data.image
          }
        );
      }
      case "Video": {
        return /* @__PURE__ */ React.createElement(Video, { ...passthroughProps, ...mediaOptions == null ? void 0 : mediaOptions.video, data });
      }
      case "ExternalVideo": {
        return /* @__PURE__ */ React.createElement(
          ExternalVideo,
          {
            ...passthroughProps,
            ...mediaOptions == null ? void 0 : mediaOptions.externalVideo,
            data
          }
        );
      }
      case "Model3d": {
        return (
          // @ts-expect-error There are issues with the inferred HTML attribute types here for ModelViewer (and contentEditable), but I think that's a little bit beyond me at the moment
          /* @__PURE__ */ React.createElement(
            ModelViewer,
            {
              ...passthroughProps,
              ...mediaOptions == null ? void 0 : mediaOptions.modelViewer,
              data
            }
          )
        );
      }
      default: {
        const typenameMissingMessage = `<MediaFile /> requires the '__typename' property to exist on the 'data' prop in order to render the matching sub-component for this type of media.`;
        {
          throw new Error(typenameMissingMessage);
        }
      }
    }
  }
  function parseMetafield(metafield) {
    if (!metafield.type) {
      const noTypeError = `parseMetafield(): The 'type' field is required in order to parse the Metafield.`;
      {
        throw new Error(noTypeError);
      }
    }
    switch (metafield.type) {
      case "boolean":
        return {
          ...metafield,
          parsedValue: metafield.value === "true"
        };
      case "collection_reference":
      case "file_reference":
      case "page_reference":
      case "product_reference":
      case "variant_reference":
        return {
          ...metafield,
          parsedValue: metafield.reference
        };
      case "color":
      case "multi_line_text_field":
      case "single_line_text_field":
      case "url":
        return {
          ...metafield,
          parsedValue: metafield.value
        };
      case "dimension":
      case "money":
      case "json":
      case "rating":
      case "volume":
      case "weight":
      case "list.color":
      case "list.dimension":
      case "list.number_integer":
      case "list.number_decimal":
      case "list.rating":
      case "list.single_line_text_field":
      case "list.url":
      case "list.volume":
      case "list.weight": {
        let parsedValue = null;
        try {
          parsedValue = parseJSON(metafield.value ?? "");
        } catch (err) {
          const parseError = `parseMetafield(): attempted to JSON.parse the 'metafield.value' property, but failed.`;
          {
            throw new Error(parseError);
          }
        }
        return {
          ...metafield,
          parsedValue
        };
      }
      case "date":
      case "date_time":
        return {
          ...metafield,
          parsedValue: new Date(metafield.value ?? "")
        };
      case "list.date":
      case "list.date_time": {
        const jsonParseValue = parseJSON((metafield == null ? void 0 : metafield.value) ?? "");
        return {
          ...metafield,
          parsedValue: jsonParseValue.map((dateString) => new Date(dateString))
        };
      }
      case "number_decimal":
      case "number_integer":
        return {
          ...metafield,
          parsedValue: Number(metafield.value)
        };
      case "list.collection_reference":
      case "list.file_reference":
      case "list.page_reference":
      case "list.product_reference":
      case "list.variant_reference":
        return {
          ...metafield,
          parsedValue: flattenConnection(metafield.references ?? void 0)
        };
      default: {
        const typeNotFoundError = `parseMetafield(): the 'metafield.type' you passed in is not supported. Your type: "${metafield.type}". If you believe this is an error, please open an issue on GitHub.`;
        {
          throw new Error(typeNotFoundError);
        }
      }
    }
  }
  function parseJSON(json) {
    if (String(json).includes("__proto__")) {
      return JSON.parse(json, (k, v2) => {
        if (k !== "__proto__")
          return v2;
      });
    }
    return JSON.parse(json);
  }
  function ProductPrice(props) {
    var _a, _b, _c, _d, _e, _f;
    const {
      priceType = "regular",
      variantId,
      valueType = "min",
      data: product,
      ...passthroughProps
    } = props;
    if (product == null) {
      throw new Error(`<ProductPrice/> requires a product as the 'data' prop`);
    }
    let price;
    let measurement;
    const variant = variantId ? flattenConnection((product == null ? void 0 : product.variants) ?? {}).find(
      (variant2) => (variant2 == null ? void 0 : variant2.id) === variantId
    ) ?? null : null;
    if (priceType === "compareAt") {
      if (variantId && variant) {
        if (((_a = variant.compareAtPriceV2) == null ? void 0 : _a.amount) === ((_b = variant.priceV2) == null ? void 0 : _b.amount)) {
          return null;
        }
        price = variant.compareAtPriceV2;
      } else if (valueType === "max") {
        price = (_c = product == null ? void 0 : product.compareAtPriceRange) == null ? void 0 : _c.maxVariantPrice;
      } else {
        price = (_d = product == null ? void 0 : product.compareAtPriceRange) == null ? void 0 : _d.minVariantPrice;
      }
    } else {
      if (variantId && variant) {
        price = variant.priceV2;
        if (valueType === "unit") {
          price = variant.unitPrice;
          measurement = variant.unitPriceMeasurement;
        }
      } else if (valueType === "max") {
        price = (_e = product.priceRange) == null ? void 0 : _e.maxVariantPrice;
      } else {
        price = (_f = product.priceRange) == null ? void 0 : _f.minVariantPrice;
      }
    }
    if (!price) {
      return null;
    }
    if (measurement) {
      return /* @__PURE__ */ React.createElement(Money, { ...passthroughProps, data: price, measurement });
    }
    return /* @__PURE__ */ React.createElement(Money, { ...passthroughProps, data: price });
  }
  const SHOPJS_URL = "https://cdn.shopify.com/shopifycloud/shop-js/v1.0/client.js";
  function ShopPayButton({
    variantIds,
    className,
    variantIdsAndQuantities,
    width,
    storeDomain: _storeDomain
  }) {
    const shop = useShop();
    const storeDomain = _storeDomain || (shop == null ? void 0 : shop.storeDomain);
    const shopPayLoadedStatus = useLoadScript(SHOPJS_URL);
    let ids = [];
    if (!storeDomain || storeDomain === defaultShopifyContext.storeDomain) {
      throw new Error(MissingStoreDomainErrorMessage);
    }
    if (variantIds && variantIdsAndQuantities) {
      throw new Error(DoublePropsErrorMessage);
    }
    if (!variantIds && !variantIdsAndQuantities) {
      throw new Error(MissingPropsErrorMessage);
    }
    if (variantIds) {
      ids = variantIds.reduce((prev, curr) => {
        const bareId = parseGid(curr).id;
        if (bareId) {
          prev.push(bareId);
        }
        return prev;
      }, []);
    } else if (variantIdsAndQuantities) {
      ids = variantIdsAndQuantities.reduce((prev, curr) => {
        const bareId = parseGid(curr == null ? void 0 : curr.id).id;
        if (bareId) {
          prev.push(`${bareId}:${(curr == null ? void 0 : curr.quantity) ?? 1}`);
        }
        return prev;
      }, []);
    } else {
      throw new Error(MissingPropsErrorMessage);
    }
    if (ids.length === 0) {
      throw new Error(InvalidPropsErrorMessage);
    }
    const style = width ? {
      "--shop-pay-button-width": width
    } : void 0;
    return /* @__PURE__ */ React.createElement("div", { className, style }, shopPayLoadedStatus === "done" && /* @__PURE__ */ React.createElement("shop-pay-button", { "store-url": storeDomain, variants: ids.join(",") }));
  }
  const MissingStoreDomainErrorMessage = 'You must pass a "storeDomain" prop to the "ShopPayButton" component, or wrap it in a "ShopifyProvider" component.';
  const InvalidPropsErrorMessage = `You must pass in "variantIds" in the form of ["gid://shopify/ProductVariant/1"]`;
  const MissingPropsErrorMessage = `You must pass in either "variantIds" or "variantIdsAndQuantities" to ShopPayButton`;
  const DoublePropsErrorMessage = `You must provide either a variantIds or variantIdsAndQuantities prop, but not both in the ShopPayButton component`;
  const longTermLength = 60 * 60 * 24 * 360 * 1;
  const shortTermLength = 60 * 30;
  function useShopifyCookies(options) {
    const { hasUserConsent = false, domain = "" } = options || {};
    React.useEffect(() => {
      const cookies = getShopifyCookies(document.cookie);
      if (hasUserConsent) {
        setCookie(
          SHOPIFY_Y,
          cookies[SHOPIFY_Y] || buildUUID(),
          longTermLength,
          domain
        );
        setCookie(
          SHOPIFY_S,
          cookies[SHOPIFY_S] || buildUUID(),
          shortTermLength,
          domain
        );
      } else {
        setCookie(SHOPIFY_Y, "", 0, domain);
        setCookie(SHOPIFY_S, "", 0, domain);
      }
    });
  }
  function setCookie(name, value, maxage, domain) {
    document.cookie = l(name, value, {
      maxage,
      domain,
      samesite: "Lax",
      path: "/"
    });
  }
  exports2.AddToCartButton = AddToCartButton;
  exports2.AnalyticsEventName = AnalyticsEventName;
  exports2.AnalyticsPageType = AnalyticsPageType;
  exports2.BuyNowButton = BuyNowButton;
  exports2.CartCheckoutButton = CartCheckoutButton;
  exports2.CartCost = CartCost;
  exports2.CartLineProvider = CartLineProvider;
  exports2.CartLineQuantity = CartLineQuantity;
  exports2.CartLineQuantityAdjustButton = CartLineQuantityAdjustButton;
  exports2.CartProvider = CartProvider;
  exports2.ExternalVideo = ExternalVideo;
  exports2.IMAGE_FRAGMENT = IMAGE_FRAGMENT;
  exports2.Image = Image;
  exports2.MediaFile = MediaFile;
  exports2.ModelViewer = ModelViewer;
  exports2.Money = Money;
  exports2.ProductPrice = ProductPrice;
  exports2.ProductProvider = ProductProvider;
  exports2.SHOPIFY_S = SHOPIFY_S;
  exports2.SHOPIFY_STOREFRONT_ID_HEADER = SHOPIFY_STOREFRONT_ID_HEADER;
  exports2.SHOPIFY_STOREFRONT_S_HEADER = SHOPIFY_STOREFRONT_S_HEADER;
  exports2.SHOPIFY_STOREFRONT_Y_HEADER = SHOPIFY_STOREFRONT_Y_HEADER;
  exports2.SHOPIFY_Y = SHOPIFY_Y;
  exports2.ShopPayButton = ShopPayButton;
  exports2.ShopifyProvider = ShopifyProvider;
  exports2.ShopifySalesChannel = ShopifySalesChannel;
  exports2.Video = Video;
  exports2.createStorefrontClient = createStorefrontClient;
  exports2.flattenConnection = flattenConnection;
  exports2.getClientBrowserParameters = getClientBrowserParameters;
  exports2.getShopifyCookies = getShopifyCookies;
  exports2.parseGid = parseGid;
  exports2.parseMetafield = parseMetafield;
  exports2.sendShopifyAnalytics = sendShopifyAnalytics;
  exports2.storefrontApiCustomScalars = storefrontApiCustomScalars;
  exports2.useCart = useCart;
  exports2.useCartLine = useCartLine;
  exports2.useMoney = useMoney;
  exports2.useProduct = useProduct;
  exports2.useShop = useShop;
  exports2.useShopifyCookies = useShopifyCookies;
  Object.defineProperty(exports2, Symbol.toStringTag, { value: "Module" });
});
//# sourceMappingURL=hydrogen-react.dev.js.map
